/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  mcp_port: 3030,
  python_path: "python3",
  embedding_model: "all-MiniLM-L6-v2",
  excluded_folders: [
    ".git",
    "node_modules",
    "dist",
    "build",
    ".venv",
    "venv",
    ".obsidian/plugins/obsidian-mcp-plugin/.venv",
    ".obsidian/plugins/obsidian-mcp-plugin/venv",
    ".obsidian/plugins/obsidian-mcp-plugin/node_modules",
    ".obsidian/plugins/obsidian-mcp-plugin/dist",
    ".obsidian/plugins/obsidian-mcp-plugin/models",
    ".obsidian/plugins/obsidian-mcp-plugin/onnx",
    ".obsidian/plugins/obsidian-mcp-plugin/openvino"
  ],
  search_default_mode: "balanced",
  search_include_linked_default: true,
  search_limit_default: 20
};

// src/settings.ts
var import_obsidian = require("obsidian");
var MCPSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "MCP Settings" });
    new import_obsidian.Setting(containerEl).setName("MCP Server Port").setDesc("The port for the MCP server.").addText((text) => text.setPlaceholder("e.g. 3030").setValue(this.plugin.settings.mcp_port.toString()).onChange(async (value) => {
      this.plugin.settings.mcp_port = Number(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Python Path").setDesc("The path to the Python executable.").addText((text) => text.setPlaceholder("e.g. /usr/bin/python3").setValue(this.plugin.settings.python_path).onChange(async (value) => {
      this.plugin.settings.python_path = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Embedding Model").setDesc("The model to use for vectorization.").addDropdown((dropdown) => dropdown.addOption("all-MiniLM-L6-v2", "all-MiniLM-L6-v2").setValue(this.plugin.settings.embedding_model).onChange(async (value) => {
      this.plugin.settings.embedding_model = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from indexing (one per line).").addTextArea((text) => text.setPlaceholder("e.g. private/\ntemplates/").setValue(this.plugin.settings.excluded_folders.join("\n")).onChange(async (value) => {
      this.plugin.settings.excluded_folders = value.split("\n").map((v) => v.trim()).filter((v) => v);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Search default mode").setDesc("Fuse ranking profile: balanced or taxonomy").addDropdown((drop) => drop.addOption("balanced", "balanced").addOption("taxonomy", "taxonomy").addOption("semantic", "semantic").setValue(this.plugin.settings.search_default_mode || "balanced").onChange(async (value) => {
      this.plugin.settings.search_default_mode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include linked notes by default").setDesc("When enabled, search results may include linked notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.search_include_linked_default ?? true).onChange(async (value) => {
      this.plugin.settings.search_include_linked_default = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default search limit").setDesc("How many items to return by default").addText((text) => text.setPlaceholder("e.g. 20").setValue(String(this.plugin.settings.search_limit_default ?? 20)).onChange(async (value) => {
      const n = Number(value);
      this.plugin.settings.search_limit_default = isNaN(n) ? 20 : n;
      await this.plugin.saveSettings();
    }));
  }
};

// src/mcp_server.ts
var import_child_process = require("child_process");
var fs = __toESM(require("fs"), 1);
var import_path = require("path");
var MCPServer = class {
  constructor(plugin) {
    __publicField(this, "process", null);
    __publicField(this, "status", "stopped");
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  get Status() {
    return this.status;
  }
  async start() {
    console.log("[MCP Server]: Attempting to start server...");
    try {
      const settings = this.plugin.settings;
      const adapter = this.plugin.app.vault.adapter;
      const pluginDir = this.plugin.manifest.dir || "obsidian-mcp-plugin";
      const manifestPath = await adapter.getResourcePath(
        `${pluginDir}/manifest.json`
      );
      const rawPath = manifestPath.replace(
        /app:\/\/local|app:\/\/[a-zA-Z0-9-]+/,
        ""
      );
      const pluginPath = (0, import_path.dirname)(decodeURIComponent(rawPath));
      console.log(`[MCP Server]: Plugin path: ${pluginPath}`);
      const serverPath = (0, import_path.normalize)(`${pluginPath}/dist/mcp_server.js`);
      const nodePath = "node";
      console.log(
        `[MCP Server]: Attempting to start server with node.js`
      );
      console.log(`[MCP Server]: Server script path: ${serverPath}`);
      if (!fs.existsSync(serverPath)) {
        console.error(
          `[MCP Server ERROR]: Server script path does not exist: ${serverPath}`
        );
        console.error(
          `[MCP Server INFO]: Run 'npm run build:mcp' to build the server`
        );
        this.status = "error";
        return;
      }
      this.process = (0, import_child_process.spawn)(nodePath, [
        serverPath,
        "--transport",
        "stdio"
      ]);
      this.status = "running";
      this.process.stdout?.on("data", (data) => {
        console.log(`[MCP Server]: ${data}`);
      });
      this.process.stderr?.on("data", (data) => {
        this.status = "error";
        console.error(`[MCP Server ERROR]: ${data}`);
      });
      this.process.on("close", (code) => {
        this.status = "stopped";
        console.log(`[MCP Server]: Process exited with code ${code}`);
      });
    } catch (e) {
      console.error("[MCP Server CATCH]:", e);
      this.status = "error";
    }
  }
  stop() {
    if (this.process) {
      this.process.kill();
      this.process = null;
      this.status = "stopped";
      console.log("[MCP Server]: Stopped");
    }
  }
  restart() {
    this.stop();
    this.start();
  }
};

// src/indexer.ts
var Indexer = class {
  constructor(plugin, modelsPath) {
    __publicField(this, "plugin");
    __publicField(this, "worker", null);
    __publicField(this, "isIndexing", false);
    __publicField(this, "modelsPath");
    this.plugin = plugin;
    this.modelsPath = modelsPath;
  }
  async startIndexing() {
    if (this.isIndexing) {
      this.plugin.indexingView?.addLog("Indexing is already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.indexingView?.onIndexingStart();
    const pluginRelativePath = this.plugin.manifest.dir;
    if (!pluginRelativePath) {
      const errorMessage = "Plugin directory is not available. Cannot start indexing.";
      this.plugin.indexingView?.addLog(`[Indexer ERROR]: ${errorMessage}`);
      this.stopIndexing();
      return;
    }
    const pluginRootUrl = this.plugin.app.vault.adapter.getResourcePath(pluginRelativePath);
    this.plugin.indexingView?.addLog(`Plugin root URL for worker: ${pluginRootUrl}`);
    this.worker = new Worker(this.plugin.workerUrl, { type: "module" });
    this.worker.onmessage = async (event) => {
      const { type, message, processed, total, indexedFiles, error } = event.data;
      switch (type) {
        case "log":
          this.plugin.indexingView?.addLog(`[Indexer Worker]: ${message}`);
          break;
        case "progress":
          this.plugin.indexingView?.updateProgress(processed, total);
          break;
        case "result":
          await this.saveIndex(indexedFiles);
          this.plugin.indexingView?.addLog("Indexing finished successfully.");
          this.stopIndexing();
          break;
        case "error":
          this.plugin.indexingView?.addLog(`[Indexer Worker ERROR]: ${error.message}
${error.stack}`);
          this.stopIndexing();
          break;
      }
    };
    this.worker.onerror = (event) => {
      event.preventDefault();
      const errorMessage = event.message || "An unknown error occurred";
      this.plugin.indexingView?.addLog(`[Indexer Worker ERROR]: ${errorMessage}`);
      console.error("Full error event:", event);
      this.stopIndexing();
    };
    const filesToIndex = await this.prepareFiles();
    this.worker.postMessage({
      type: "start",
      files: filesToIndex,
      model: this.plugin.settings.embedding_model,
      mcpPort: this.plugin.settings.mcp_port
      // Передаем порт MCP-сервера
    });
  }
  // ВОТ ЭТОТ МЕТОД БЫЛ ПОТЕРЯН. Я ЕГО ВЕРНУЛ.
  stopIndexing() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isIndexing = false;
    this.plugin.indexingView?.onIndexingStop();
  }
  async prepareFiles() {
    const files = this.plugin.app.vault.getMarkdownFiles();
    const excludedFolders = this.plugin.settings.excluded_folders;
    const defaultExcludes = [
      ".obsidian/",
      "node_modules/",
      ".venv/",
      "venv/",
      "dist/",
      "build/"
    ];
    const filesToProcess = files.filter((file) => {
      const p = file.path;
      if (defaultExcludes.some((pref) => p.startsWith(pref) || p.includes("/" + pref)))
        return false;
      if (excludedFolders.some((folder) => p.startsWith(folder)))
        return false;
      return true;
    });
    const fileContents = await Promise.all(
      filesToProcess.map(async (file) => ({
        path: file.path,
        content: await this.plugin.app.vault.cachedRead(file)
      }))
    );
    return fileContents;
  }
  async saveIndex(indexedFiles) {
    const indexPath = `${this.plugin.app.vault.configDir}/plugins/obsidian-mcp-plugin/index.json`;
    await this.plugin.app.vault.adapter.write(indexPath, JSON.stringify(indexedFiles, null, 2));
  }
};

// src/indexing_view.ts
var import_obsidian2 = require("obsidian");
var INDEXING_VIEW_TYPE = "mcp-indexing-view";
var IndexingView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "logContainer");
    __publicField(this, "progressBar");
    this.plugin = plugin;
  }
  getViewType() {
    return INDEXING_VIEW_TYPE;
  }
  getDisplayText() {
    return "MCP Indexing";
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    container.createEl("h2", { text: "MCP Indexing Status" });
    const statusSection = container.createDiv();
    statusSection.createEl("h3", { text: "Status" });
    const controlsSection = container.createDiv();
    controlsSection.createEl("h3", { text: "Controls" });
    const startButton = controlsSection.createEl("button", { text: "Start Indexing" });
    const stopButton = controlsSection.createEl("button", { text: "Stop Indexing", attr: { disabled: "true" } });
    const restartServerButton = controlsSection.createEl("button", { text: "Restart MCP Server" });
    startButton.onClickEvent(() => this.plugin.indexer.startIndexing());
    stopButton.onClickEvent(() => this.plugin.indexer.stopIndexing());
    restartServerButton.onClickEvent(() => this.plugin.mcpServer.restart());
    const progressSection = container.createDiv();
    progressSection.createEl("h3", { text: "Progress" });
    this.progressBar = progressSection.createEl("progress");
    this.progressBar.style.width = "100%";
    const logsSection = container.createDiv();
    logsSection.createEl("h3", { text: "Logs" });
    this.logContainer = logsSection.createEl("div", { cls: "mcp-log-container" });
  }
  addLog(message) {
    const logLine = this.logContainer.createEl("div", { text: message });
    this.logContainer.scrollTop = this.logContainer.scrollHeight;
  }
  updateProgress(processed, total) {
    this.progressBar.max = total;
    this.progressBar.value = processed;
  }
  onIndexingStart() {
    this.containerEl.querySelector('button[text="Start Indexing"]')?.setAttribute("disabled", "true");
    this.containerEl.querySelector('button[text="Stop Indexing"]')?.removeAttribute("disabled");
  }
  onIndexingStop() {
    this.containerEl.querySelector('button[text="Start Indexing"]')?.removeAttribute("disabled");
    this.containerEl.querySelector('button[text="Stop Indexing"]')?.setAttribute("disabled", "true");
    this.progressBar.value = 0;
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "mcpServer");
    __publicField(this, "indexer");
    __publicField(this, "indexingView");
    __publicField(this, "workerUrl");
  }
  async onload() {
    await this.loadSettings();
    const workerPath = `${this.manifest.dir}/worker.js`;
    const workerBlob = new Blob([await this.app.vault.adapter.read(workerPath)], { type: "text/javascript" });
    this.workerUrl = URL.createObjectURL(workerBlob);
    this.mcpServer = new MCPServer(this);
    const modelsPath = `${this.manifest.dir}/models`;
    this.indexer = new Indexer(this, modelsPath);
    this.addSettingTab(new MCPSettingsTab(this.app, this));
    this.registerView(
      INDEXING_VIEW_TYPE,
      (leaf) => this.indexingView = new IndexingView(leaf, this)
    );
    this.addRibbonIcon("brain-circuit", "Activate MCP Indexing View", () => {
      this.activateView();
    });
    this.addCommand({
      id: "start-indexing",
      name: "Start Indexing",
      callback: () => {
        this.indexer.startIndexing();
      }
    });
    await this.setupPythonEnvironment();
    await this.mcpServer.start();
  }
  onunload() {
    this.mcpServer.stop();
    if (this.indexingView) {
      this.indexingView.leaf.detach();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async setupPythonEnvironment() {
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(INDEXING_VIEW_TYPE);
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: INDEXING_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3R5cGVzLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvbWNwX3NlcnZlci50cyIsICJzcmMvaW5kZXhlci50cyIsICJzcmMvaW5kZXhpbmdfdmlldy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgTUNQU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE1DUFNldHRpbmdzVGFiIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBNQ1BTZXJ2ZXIgfSBmcm9tICcuL21jcF9zZXJ2ZXInO1xuaW1wb3J0IHsgSW5kZXhlciB9IGZyb20gJy4vaW5kZXhlcic7XG5pbXBvcnQgeyBJbmRleGluZ1ZpZXcsIElOREVYSU5HX1ZJRVdfVFlQRSB9IGZyb20gJy4vaW5kZXhpbmdfdmlldyc7XG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplLCBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogTUNQU2V0dGluZ3M7XG4gICAgbWNwU2VydmVyOiBNQ1BTZXJ2ZXI7XG4gICAgaW5kZXhlcjogSW5kZXhlcjtcbiAgICBpbmRleGluZ1ZpZXc6IEluZGV4aW5nVmlldztcbiAgICB3b3JrZXJVcmw6IHN0cmluZztcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgY29uc3Qgd29ya2VyUGF0aCA9IGAke3RoaXMubWFuaWZlc3QuZGlyfS93b3JrZXIuanNgO1xuICAgICAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoW2F3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZCh3b3JrZXJQYXRoKV0sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgICAgIHRoaXMud29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcblxuICAgICAgICB0aGlzLm1jcFNlcnZlciA9IG5ldyBNQ1BTZXJ2ZXIodGhpcyk7XG4gICAgICAgIGNvbnN0IG1vZGVsc1BhdGggPSBgJHt0aGlzLm1hbmlmZXN0LmRpcn0vbW9kZWxzYDtcbiAgICAgICAgdGhpcy5pbmRleGVyID0gbmV3IEluZGV4ZXIodGhpcywgbW9kZWxzUGF0aCk7XG5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBNQ1BTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFxuICAgICAgICAgICAgSU5ERVhJTkdfVklFV19UWVBFLFxuICAgICAgICAgICAgKGxlYWYpID0+ICh0aGlzLmluZGV4aW5nVmlldyA9IG5ldyBJbmRleGluZ1ZpZXcobGVhZiwgdGhpcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdicmFpbi1jaXJjdWl0JywgJ0FjdGl2YXRlIE1DUCBJbmRleGluZyBWaWV3JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZpZXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnc3RhcnQtaW5kZXhpbmcnLFxuICAgICAgICAgICAgbmFtZTogJ1N0YXJ0IEluZGV4aW5nJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVyLnN0YXJ0SW5kZXhpbmcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0dXBQeXRob25FbnZpcm9ubWVudCgpO1xuICAgICAgICBhd2FpdCB0aGlzLm1jcFNlcnZlci5zdGFydCgpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICB0aGlzLm1jcFNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmluZGV4aW5nVmlldykge1xuICAgICAgICAgICAgdGhpcy5pbmRleGluZ1ZpZXcubGVhZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNldHVwUHl0aG9uRW52aXJvbm1lbnQoKSB7XG4gICAgICAgIC8vIC4uLlxuICAgIH1cblxuICAgIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShJTkRFWElOR19WSUVXX1RZUEUpO1xuXG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTtcbiAgICAgICAgaWYgKGxlYWYpIHtcbiAgICAgICAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTkRFWElOR19WSUVXX1RZUEUsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICB9XG4gICAgfVxufSIsICJleHBvcnQgaW50ZXJmYWNlIE1DUFNldHRpbmdzIHtcbiAgICBtY3BfcG9ydDogbnVtYmVyO1xuICAgIHB5dGhvbl9wYXRoOiBzdHJpbmc7XG4gICAgZW1iZWRkaW5nX21vZGVsOiBzdHJpbmc7XG4gICAgZXhjbHVkZWRfZm9sZGVyczogc3RyaW5nW107XG4gICAgc2VhcmNoX2RlZmF1bHRfbW9kZT86ICdiYWxhbmNlZCcgfCAndGF4b25vbXknIHwgJ3NlbWFudGljJztcbiAgICBzZWFyY2hfaW5jbHVkZV9saW5rZWRfZGVmYXVsdD86IGJvb2xlYW47XG4gICAgc2VhcmNoX2xpbWl0X2RlZmF1bHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNQ1BTZXR0aW5ncyA9IHtcbiAgICBtY3BfcG9ydDogMzAzMCxcbiAgIHB5dGhvbl9wYXRoOiAncHl0aG9uMycsXG4gICAgZW1iZWRkaW5nX21vZGVsOiAnYWxsLU1pbmlMTS1MNi12MicsXG4gICAgZXhjbHVkZWRfZm9sZGVyczogW1xuICAgICAgICAnLmdpdCcsXG4gICAgICAgICdub2RlX21vZHVsZXMnLFxuICAgICAgICAnZGlzdCcsXG4gICAgICAgICdidWlsZCcsXG4gICAgICAgICcudmVudicsXG4gICAgICAgICd2ZW52JyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vLnZlbnYnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi92ZW52JyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vbm9kZV9tb2R1bGVzJyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vZGlzdCcsXG4gICAgICAgICcub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL21vZGVscycsXG4gICAgICAgICcub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL29ubngnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi9vcGVudmlubydcbiAgICBdLFxuICAgIHNlYXJjaF9kZWZhdWx0X21vZGU6ICdiYWxhbmNlZCcsXG4gICAgc2VhcmNoX2luY2x1ZGVfbGlua2VkX2RlZmF1bHQ6IHRydWUsXG4gICAgc2VhcmNoX2xpbWl0X2RlZmF1bHQ6IDIwLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBJbmRleGVkRmlsZSB7XG4gICAgcGF0aDogc3RyaW5nO1xuICAgIGNvbnRlbnRfcHJldmlldzogc3RyaW5nO1xuICAgIHZlY3RvcjogbnVtYmVyW107XG59IiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNeVBsdWdpbiBmcm9tICcuL21haW4nOyAvLyBBc3N1bWluZyBNeVBsdWdpbiBpcyB0aGUgbmFtZSBvZiB0aGUgbWFpbiBwbHVnaW4gY2xhc3NcblxuZXhwb3J0IGNsYXNzIE1DUFNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiBNeVBsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ01DUCBTZXR0aW5ncycgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTUNQIFNlcnZlciBQb3J0JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgcG9ydCBmb3IgdGhlIE1DUCBzZXJ2ZXIuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiAzMDMwJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWNwX3BvcnQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1jcF9wb3J0ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1B5dGhvbiBQYXRoJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgcGF0aCB0byB0aGUgUHl0aG9uIGV4ZWN1dGFibGUuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiAvdXNyL2Jpbi9weXRob24zJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHl0aG9uX3BhdGgpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25fcGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRW1iZWRkaW5nIE1vZGVsJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbW9kZWwgdG8gdXNlIGZvciB2ZWN0b3JpemF0aW9uLicpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdhbGwtTWluaUxNLUw2LXYyJywgJ2FsbC1NaW5pTE0tTDYtdjInKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbWJlZGRpbmdfbW9kZWwpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbWJlZGRpbmdfbW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0V4Y2x1ZGVkIEZvbGRlcnMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0ZvbGRlcnMgdG8gZXhjbHVkZSBmcm9tIGluZGV4aW5nIChvbmUgcGVyIGxpbmUpLicpXG4gICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuIHByaXZhdGUvXFxudGVtcGxhdGVzLycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGVkX2ZvbGRlcnMuam9pbignXFxuJykpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlZF9mb2xkZXJzID0gdmFsdWUuc3BsaXQoJ1xcbicpLm1hcCh2ID0+IHYudHJpbSgpKS5maWx0ZXIodiA9PiB2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1NlYXJjaCBkZWZhdWx0IG1vZGUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0Z1c2UgcmFua2luZyBwcm9maWxlOiBiYWxhbmNlZCBvciB0YXhvbm9teScpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcCA9PiBkcm9wXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignYmFsYW5jZWQnLCAnYmFsYW5jZWQnKVxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ3RheG9ub215JywgJ3RheG9ub215JylcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdzZW1hbnRpYycsICdzZW1hbnRpYycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlYXJjaF9kZWZhdWx0X21vZGUgfHwgJ2JhbGFuY2VkJylcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlYXJjaF9kZWZhdWx0X21vZGUgPSB2YWx1ZSBhcyBhbnk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdJbmNsdWRlIGxpbmtlZCBub3RlcyBieSBkZWZhdWx0JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdXaGVuIGVuYWJsZWQsIHNlYXJjaCByZXN1bHRzIG1heSBpbmNsdWRlIGxpbmtlZCBub3RlcycpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VhcmNoX2luY2x1ZGVfbGlua2VkX2RlZmF1bHQgPz8gdHJ1ZSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlYXJjaF9pbmNsdWRlX2xpbmtlZF9kZWZhdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdEZWZhdWx0IHNlYXJjaCBsaW1pdCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnSG93IG1hbnkgaXRlbXMgdG8gcmV0dXJuIGJ5IGRlZmF1bHQnKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuIDIwJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUoU3RyaW5nKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlYXJjaF9saW1pdF9kZWZhdWx0ID8/IDIwKSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWFyY2hfbGltaXRfZGVmYXVsdCA9IGlzTmFOKG4pID8gMjAgOiBuO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxufSIsICJpbXBvcnQgeyBDaGlsZFByb2Nlc3MsIHNwYXduIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgTUNQU2V0dGluZ3MgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IG5vcm1hbGl6ZSwgZGlybmFtZSB9IGZyb20gXCJwYXRoXCI7XG5cbmV4cG9ydCB0eXBlIFNlcnZlclN0YXR1cyA9IFwicnVubmluZ1wiIHwgXCJzdG9wcGVkXCIgfCBcImVycm9yXCI7XG5cbmV4cG9ydCBjbGFzcyBNQ1BTZXJ2ZXIge1xuICBwcml2YXRlIHByb2Nlc3M6IENoaWxkUHJvY2VzcyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0YXR1czogU2VydmVyU3RhdHVzID0gXCJzdG9wcGVkXCI7XG4gIHByaXZhdGUgcGx1Z2luOiBNeVBsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihwbHVnaW46IE15UGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICBnZXQgU3RhdHVzKCk6IFNlcnZlclN0YXR1cyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xuICB9XG5cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgY29uc29sZS5sb2coXCJbTUNQIFNlcnZlcl06IEF0dGVtcHRpbmcgdG8gc3RhcnQgc2VydmVyLi4uXCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucGx1Z2luLnNldHRpbmdzO1xuICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyO1xuICAgICAgY29uc3QgcGx1Z2luRGlyID0gdGhpcy5wbHVnaW4ubWFuaWZlc3QuZGlyIHx8IFwib2JzaWRpYW4tbWNwLXBsdWdpblwiO1xuXG4gICAgICAvLyBBIG1vcmUgcmVsaWFibGUgd2F5IHRvIGdldCB0aGUgcGx1Z2luIHBhdGhcbiAgICAgIGNvbnN0IG1hbmlmZXN0UGF0aCA9IGF3YWl0IGFkYXB0ZXIuZ2V0UmVzb3VyY2VQYXRoKFxuICAgICAgICBgJHtwbHVnaW5EaXJ9L21hbmlmZXN0Lmpzb25gLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJhd1BhdGggPSBtYW5pZmVzdFBhdGgucmVwbGFjZShcbiAgICAgICAgL2FwcDpcXC9cXC9sb2NhbHxhcHA6XFwvXFwvW2EtekEtWjAtOS1dKy8sXG4gICAgICAgIFwiXCIsXG4gICAgICApO1xuICAgICAgY29uc3QgcGx1Z2luUGF0aCA9IGRpcm5hbWUoZGVjb2RlVVJJQ29tcG9uZW50KHJhd1BhdGgpKTtcblxuICAgICAgY29uc29sZS5sb2coYFtNQ1AgU2VydmVyXTogUGx1Z2luIHBhdGg6ICR7cGx1Z2luUGF0aH1gKTtcblxuICAgICAgY29uc3Qgc2VydmVyUGF0aCA9IG5vcm1hbGl6ZShgJHtwbHVnaW5QYXRofS9kaXN0L21jcF9zZXJ2ZXIuanNgKTtcbiAgICAgIGNvbnN0IG5vZGVQYXRoID0gXCJub2RlXCI7IC8vIFx1MDQxRlx1MDQ0MFx1MDQzNVx1MDQzNFx1MDQzRlx1MDQzRVx1MDQzQlx1MDQzMFx1MDQzM1x1MDQzMFx1MDQzNVx1MDQzQyBcdTA0NDdcdTA0NDJcdTA0M0UgTm9kZS5qcyBcdTA0MzIgUEFUSFxuXG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYFtNQ1AgU2VydmVyXTogQXR0ZW1wdGluZyB0byBzdGFydCBzZXJ2ZXIgd2l0aCBub2RlLmpzYCxcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhgW01DUCBTZXJ2ZXJdOiBTZXJ2ZXIgc2NyaXB0IHBhdGg6ICR7c2VydmVyUGF0aH1gKTtcblxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHNlcnZlclBhdGgpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFtNQ1AgU2VydmVyIEVSUk9SXTogU2VydmVyIHNjcmlwdCBwYXRoIGRvZXMgbm90IGV4aXN0OiAke3NlcnZlclBhdGh9YCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW01DUCBTZXJ2ZXIgSU5GT106IFJ1biAnbnBtIHJ1biBidWlsZDptY3AnIHRvIGJ1aWxkIHRoZSBzZXJ2ZXJgLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZXJyb3JcIjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2Nlc3MgPSBzcGF3bihub2RlUGF0aCwgW1xuICAgICAgICBzZXJ2ZXJQYXRoLFxuICAgICAgICBcIi0tdHJhbnNwb3J0XCIsXG4gICAgICAgIFwic3RkaW9cIlxuICAgICAgXSk7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwicnVubmluZ1wiO1xuXG4gICAgICB0aGlzLnByb2Nlc3Muc3Rkb3V0Py5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYFtNQ1AgU2VydmVyXTogJHtkYXRhfWApO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJvY2Vzcy5zdGRlcnI/Lm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZXJyb3JcIjtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW01DUCBTZXJ2ZXIgRVJST1JdOiAke2RhdGF9YCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wcm9jZXNzLm9uKFwiY2xvc2VcIiwgKGNvZGUpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcInN0b3BwZWRcIjtcbiAgICAgICAgY29uc29sZS5sb2coYFtNQ1AgU2VydmVyXTogUHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTUNQIFNlcnZlciBDQVRDSF06XCIsIGUpO1xuICAgICAgdGhpcy5zdGF0dXMgPSBcImVycm9yXCI7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5wcm9jZXNzKSB7XG4gICAgICB0aGlzLnByb2Nlc3Mua2lsbCgpO1xuICAgICAgdGhpcy5wcm9jZXNzID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJzdG9wcGVkXCI7XG4gICAgICBjb25zb2xlLmxvZyhcIltNQ1AgU2VydmVyXTogU3RvcHBlZFwiKTtcbiAgICB9XG4gIH1cblxuICByZXN0YXJ0KCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUsIERhdGFBZGFwdGVyLCBub3JtYWxpemVQYXRoIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gJy4vbWFpbic7XG5pbXBvcnQgeyBJbmRleGVkRmlsZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgSW5kZXhlciB7XG4gICAgcHJpdmF0ZSBwbHVnaW46IE15UGx1Z2luO1xuICAgIHByaXZhdGUgd29ya2VyOiBXb3JrZXIgfCBudWxsID0gbnVsbDtcbiAgICBwdWJsaWMgaXNJbmRleGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgbW9kZWxzUGF0aDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBNeVBsdWdpbiwgbW9kZWxzUGF0aDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgICAgICB0aGlzLm1vZGVsc1BhdGggPSBtb2RlbHNQYXRoOyAvLyBcdTA0MkRcdTA0NDJcdTA0M0VcdTA0NDIgXHUwNDNGXHUwNDMwXHUwNDQwXHUwNDMwXHUwNDNDXHUwNDM1XHUwNDQyXHUwNDQwIFx1MDQzMVx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQ0OFx1MDQzNSBcdTA0M0RcdTA0MzUgXHUwNDM4XHUwNDQxXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDM3XHUwNDQzXHUwNDM1XHUwNDQyXHUwNDQxXHUwNDRGIFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0MzJcdTA0M0VcdTA0NDBcdTA0M0FcdTA0MzVcdTA0NDBcdTA0MzAsIFx1MDQzRFx1MDQzRSBcdTA0M0VcdTA0NDFcdTA0NDJcdTA0MzBcdTA0MzJcdTA0MzhcdTA0M0MgXHUwNDM0XHUwNDNCXHUwNDRGIFx1MDQzRlx1MDQzRVx1MDQ0MFx1MDQ0Rlx1MDQzNFx1MDQzQVx1MDQzMFxuICAgIH1cblxuICAgIGFzeW5jIHN0YXJ0SW5kZXhpbmcoKSB7XG4gICAgaWYgKHRoaXMuaXNJbmRleGluZykge1xuICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZygnSW5kZXhpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNJbmRleGluZyA9IHRydWU7XG4gICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5vbkluZGV4aW5nU3RhcnQoKTtcblxuICAgIC8vIC0tLSBcdTA0MURcdTA0MTBcdTA0MjdcdTA0MTBcdTA0MUJcdTA0MUUgXHUwNDI0XHUwNDE4XHUwNDFEXHUwNDEwXHUwNDFCXHUwNDJDXHUwNDFEXHUwNDFFXHUwNDEzXHUwNDFFIFx1MDQxOFx1MDQyMVx1MDQxRlx1MDQyMFx1MDQxMFx1MDQxMlx1MDQxQlx1MDQxNVx1MDQxRFx1MDQxOFx1MDQyRiAtLS1cblxuICAgIGNvbnN0IHBsdWdpblJlbGF0aXZlUGF0aCA9IHRoaXMucGx1Z2luLm1hbmlmZXN0LmRpcjtcblxuICAgIGlmICghcGx1Z2luUmVsYXRpdmVQYXRoKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IFwiUGx1Z2luIGRpcmVjdG9yeSBpcyBub3QgYXZhaWxhYmxlLiBDYW5ub3Qgc3RhcnQgaW5kZXhpbmcuXCI7XG4gICAgICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8uYWRkTG9nKGBbSW5kZXhlciBFUlJPUl06ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB0aGlzLnN0b3BJbmRleGluZygpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYGdldFJlc291cmNlUGF0aGAgXHUwNDNBXHUwNDMwXHUwNDNBIFx1MDQ0MFx1MDQzMFx1MDQzNyBcdTA0MzggXHUwNDNFXHUwNDM2XHUwNDM4XHUwNDM0XHUwNDMwXHUwNDM1XHUwNDQyIFx1MDQzRlx1MDQ0M1x1MDQ0Mlx1MDQ0QyBcdTA0M0VcdTA0NDJcdTA0M0RcdTA0M0VcdTA0NDFcdTA0MzhcdTA0NDJcdTA0MzVcdTA0M0JcdTA0NENcdTA0M0RcdTA0M0UgXHUwNDNBXHUwNDNFXHUwNDQwXHUwNDNEXHUwNDRGIFx1MDQ0NVx1MDQ0MFx1MDQzMFx1MDQzRFx1MDQzOFx1MDQzQlx1MDQzOFx1MDQ0OVx1MDQzMC5cbiAgICAvLyBgbWFuaWZlc3QuZGlyYCBcdTA0MzhcdTA0M0NcdTA0MzVcdTA0M0RcdTA0M0RcdTA0M0UgXHUwNDM1XHUwNDMzXHUwNDNFIFx1MDQzOCBcdTA0M0ZcdTA0NDBcdTA0MzVcdTA0MzRcdTA0M0VcdTA0NDFcdTA0NDJcdTA0MzBcdTA0MzJcdTA0M0JcdTA0NEZcdTA0MzVcdTA0NDIuXG4gICAgY29uc3QgcGx1Z2luUm9vdFVybCA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLmdldFJlc291cmNlUGF0aChwbHVnaW5SZWxhdGl2ZVBhdGgpO1xuXG4gICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coYFBsdWdpbiByb290IFVSTCBmb3Igd29ya2VyOiAke3BsdWdpblJvb3RVcmx9YCk7XG5cbiAgICAvLyAtLS0gXHUwNDFBXHUwNDFFXHUwNDFEXHUwNDE1XHUwNDI2IFx1MDQyNFx1MDQxOFx1MDQxRFx1MDQxMFx1MDQxQlx1MDQyQ1x1MDQxRFx1MDQxRVx1MDQxM1x1MDQxRSBcdTA0MThcdTA0MjFcdTA0MUZcdTA0MjBcdTA0MTBcdTA0MTJcdTA0MUJcdTA0MTVcdTA0MURcdTA0MThcdTA0MkYgLS0tXG5cbiAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIodGhpcy5wbHVnaW4ud29ya2VyVXJsLCB7IHR5cGU6ICdtb2R1bGUnIH0pO1xuXG4gICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgbWVzc2FnZSwgcHJvY2Vzc2VkLCB0b3RhbCwgaW5kZXhlZEZpbGVzLCBlcnJvciB9ID0gZXZlbnQuZGF0YTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coYFtJbmRleGVyIFdvcmtlcl06ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LnVwZGF0ZVByb2dyZXNzKHByb2Nlc3NlZCwgdG90YWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzdWx0JzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVJbmRleChpbmRleGVkRmlsZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8uYWRkTG9nKCdJbmRleGluZyBmaW5pc2hlZCBzdWNjZXNzZnVsbHkuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wSW5kZXhpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZyhgW0luZGV4ZXIgV29ya2VyIEVSUk9SXTogJHtlcnJvci5tZXNzYWdlfVxcbiR7ZXJyb3Iuc3RhY2t9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wSW5kZXhpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLndvcmtlci5vbmVycm9yID0gKGV2ZW50OiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGV2ZW50Lm1lc3NhZ2UgfHwgJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQnO1xuICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZyhgW0luZGV4ZXIgV29ya2VyIEVSUk9SXTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bGwgZXJyb3IgZXZlbnQ6JywgZXZlbnQpO1xuICAgICAgICB0aGlzLnN0b3BJbmRleGluZygpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaWxlc1RvSW5kZXggPSBhd2FpdCB0aGlzLnByZXBhcmVGaWxlcygpO1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ3N0YXJ0JyxcbiAgICAgICAgZmlsZXM6IGZpbGVzVG9JbmRleCxcbiAgICAgICAgbW9kZWw6IHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYmVkZGluZ19tb2RlbCxcbiAgICAgICAgbWNwUG9ydDogdGhpcy5wbHVnaW4uc2V0dGluZ3MubWNwX3BvcnQsIC8vIFx1MDQxRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQzNFx1MDQzMFx1MDQzNVx1MDQzQyBcdTA0M0ZcdTA0M0VcdTA0NDBcdTA0NDIgTUNQLVx1MDQ0MVx1MDQzNVx1MDQ0MFx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQzMFxuICAgIH0pO1xufVxuXG4gICAgLy8gXHUwNDEyXHUwNDFFXHUwNDIyIFx1MDQyRFx1MDQyMlx1MDQxRVx1MDQyMiBcdTA0MUNcdTA0MTVcdTA0MjJcdTA0MUVcdTA0MTQgXHUwNDExXHUwNDJCXHUwNDFCIFx1MDQxRlx1MDQxRVx1MDQyMlx1MDQxNVx1MDQyMFx1MDQyRlx1MDQxRC4gXHUwNDJGIFx1MDQxNVx1MDQxM1x1MDQxRSBcdTA0MTJcdTA0MTVcdTA0MjBcdTA0MURcdTA0MjNcdTA0MUIuXG4gICAgcHVibGljIHN0b3BJbmRleGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSW5kZXhpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5vbkluZGV4aW5nU3RvcCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcHJlcGFyZUZpbGVzKCk6IFByb21pc2U8eyBwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyB9W10+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICAgICAgICBjb25zdCBleGNsdWRlZEZvbGRlcnMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlZF9mb2xkZXJzO1xuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRFeGNsdWRlcyA9IFtcbiAgICAgICAgICAgICcub2JzaWRpYW4vJyxcbiAgICAgICAgICAgICdub2RlX21vZHVsZXMvJyxcbiAgICAgICAgICAgICcudmVudi8nLFxuICAgICAgICAgICAgJ3ZlbnYvJyxcbiAgICAgICAgICAgICdkaXN0LycsXG4gICAgICAgICAgICAnYnVpbGQvJ1xuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGZpbGVzVG9Qcm9jZXNzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgcCA9IGZpbGUucGF0aDtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RXhjbHVkZXMuc29tZShwcmVmID0+IHAuc3RhcnRzV2l0aChwcmVmKSB8fCBwLmluY2x1ZGVzKCcvJyArIHByZWYpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkRm9sZGVycy5zb21lKGZvbGRlciA9PiBwLnN0YXJ0c1dpdGgoZm9sZGVyKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBmaWxlQ29udGVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGZpbGVzVG9Qcm9jZXNzLm1hcChhc3luYyAoZmlsZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgICAgICAgICAgY29udGVudDogYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSksXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnRzO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgc2F2ZUluZGV4KGluZGV4ZWRGaWxlczogSW5kZXhlZEZpbGVbXSkge1xuICAgICAgICBjb25zdCBpbmRleFBhdGggPSBgJHt0aGlzLnBsdWdpbi5hcHAudmF1bHQuY29uZmlnRGlyfS9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vaW5kZXguanNvbmA7XG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKGluZGV4UGF0aCwgSlNPTi5zdHJpbmdpZnkoaW5kZXhlZEZpbGVzLCBudWxsLCAyKSk7XG4gICAgfVxufSIsICJpbXBvcnQgeyBJdGVtVmlldywgV29ya3NwYWNlTGVhZiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNeVBsdWdpbiBmcm9tICcuL21haW4nO1xuXG5leHBvcnQgY29uc3QgSU5ERVhJTkdfVklFV19UWVBFID0gJ21jcC1pbmRleGluZy12aWV3JztcblxuZXhwb3J0IGNsYXNzIEluZGV4aW5nVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgICBwcml2YXRlIHBsdWdpbjogTXlQbHVnaW47XG4gICAgcHJpdmF0ZSBsb2dDb250YWluZXI6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgcHJvZ3Jlc3NCYXI6IEhUTUxQcm9ncmVzc0VsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihsZWFmOiBXb3Jrc3BhY2VMZWFmLCBwbHVnaW46IE15UGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBnZXRWaWV3VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIElOREVYSU5HX1ZJRVdfVFlQRTtcbiAgICB9XG5cbiAgICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuICdNQ1AgSW5kZXhpbmcnO1xuICAgIH1cblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250ZW50RWw7XG4gICAgICAgIGNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICBjb250YWluZXIuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnTUNQIEluZGV4aW5nIFN0YXR1cycgfSk7XG5cbiAgICAgICAgLy8gU3RhdHVzIHNlY3Rpb25cbiAgICAgICAgY29uc3Qgc3RhdHVzU2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgc3RhdHVzU2VjdGlvbi5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdTdGF0dXMnIH0pO1xuICAgICAgICAvLyBBZGQgc3RhdHVzIGluZGljYXRvcnMgaGVyZSBsYXRlclxuXG4gICAgICAgIC8vIENvbnRyb2xzIHNlY3Rpb25cbiAgICAgICAgY29uc3QgY29udHJvbHNTZWN0aW9uID0gY29udGFpbmVyLmNyZWF0ZURpdigpO1xuICAgICAgICBjb250cm9sc1NlY3Rpb24uY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnQ29udHJvbHMnIH0pO1xuICAgICAgICBjb25zdCBzdGFydEJ1dHRvbiA9IGNvbnRyb2xzU2VjdGlvbi5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnU3RhcnQgSW5kZXhpbmcnIH0pO1xuICAgICAgICBjb25zdCBzdG9wQnV0dG9uID0gY29udHJvbHNTZWN0aW9uLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdTdG9wIEluZGV4aW5nJywgYXR0cjogeyBkaXNhYmxlZDogJ3RydWUnIH0gfSk7XG4gICAgICAgIGNvbnN0IHJlc3RhcnRTZXJ2ZXJCdXR0b24gPSBjb250cm9sc1NlY3Rpb24uY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ1Jlc3RhcnQgTUNQIFNlcnZlcicgfSk7XG5cbiAgICAgICAgc3RhcnRCdXR0b24ub25DbGlja0V2ZW50KCgpID0+IHRoaXMucGx1Z2luLmluZGV4ZXIuc3RhcnRJbmRleGluZygpKTtcbiAgICAgICAgc3RvcEJ1dHRvbi5vbkNsaWNrRXZlbnQoKCkgPT4gdGhpcy5wbHVnaW4uaW5kZXhlci5zdG9wSW5kZXhpbmcoKSk7XG4gICAgICAgIHJlc3RhcnRTZXJ2ZXJCdXR0b24ub25DbGlja0V2ZW50KCgpID0+IHRoaXMucGx1Z2luLm1jcFNlcnZlci5yZXN0YXJ0KCkpO1xuXG4gICAgICAgIC8vIFByb2dyZXNzIHNlY3Rpb25cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NTZWN0aW9uID0gY29udGFpbmVyLmNyZWF0ZURpdigpO1xuICAgICAgICBwcm9ncmVzc1NlY3Rpb24uY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnUHJvZ3Jlc3MnIH0pO1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyID0gcHJvZ3Jlc3NTZWN0aW9uLmNyZWF0ZUVsKCdwcm9ncmVzcycpO1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXG4gICAgICAgIC8vIExvZ3Mgc2VjdGlvblxuICAgICAgICBjb25zdCBsb2dzU2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgbG9nc1NlY3Rpb24uY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnTG9ncycgfSk7XG4gICAgICAgIHRoaXMubG9nQ29udGFpbmVyID0gbG9nc1NlY3Rpb24uY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnbWNwLWxvZy1jb250YWluZXInIH0pO1xuICAgIH1cblxuICAgIGFkZExvZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgbG9nTGluZSA9IHRoaXMubG9nQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IHRleHQ6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHRoaXMubG9nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubG9nQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICB9XG5cbiAgICB1cGRhdGVQcm9ncmVzcyhwcm9jZXNzZWQ6IG51bWJlciwgdG90YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLm1heCA9IHRvdGFsO1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLnZhbHVlID0gcHJvY2Vzc2VkO1xuICAgIH1cblxuICAgIG9uSW5kZXhpbmdTdGFydCgpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCdidXR0b25bdGV4dD1cIlN0YXJ0IEluZGV4aW5nXCJdJyk/LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvblt0ZXh0PVwiU3RvcCBJbmRleGluZ1wiXScpPy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgb25JbmRleGluZ1N0b3AoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignYnV0dG9uW3RleHQ9XCJTdGFydCBJbmRleGluZ1wiXScpPy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignYnV0dG9uW3RleHQ9XCJTdG9wIEluZGV4aW5nXCJdJyk/LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICB0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
