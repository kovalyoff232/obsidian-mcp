/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  mcp_port: 3030,
  python_path: "python3",
  embedding_model: "all-MiniLM-L6-v2",
  excluded_folders: [
    ".git",
    "node_modules",
    "dist",
    "build",
    ".venv",
    "venv",
    ".obsidian/plugins/obsidian-mcp-plugin/.venv",
    ".obsidian/plugins/obsidian-mcp-plugin/venv",
    ".obsidian/plugins/obsidian-mcp-plugin/node_modules",
    ".obsidian/plugins/obsidian-mcp-plugin/dist",
    ".obsidian/plugins/obsidian-mcp-plugin/models",
    ".obsidian/plugins/obsidian-mcp-plugin/onnx",
    ".obsidian/plugins/obsidian-mcp-plugin/openvino"
  ],
  search_default_mode: "balanced",
  search_include_linked_default: true,
  search_limit_default: 20
};

// src/settings.ts
var import_obsidian = require("obsidian");
var MCPSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "MCP Settings" });
    new import_obsidian.Setting(containerEl).setName("MCP Server Port").setDesc("The port for the MCP server.").addText((text) => text.setPlaceholder("e.g. 3030").setValue(this.plugin.settings.mcp_port.toString()).onChange(async (value) => {
      this.plugin.settings.mcp_port = Number(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Python Path").setDesc("The path to the Python executable.").addText((text) => text.setPlaceholder("e.g. /usr/bin/python3").setValue(this.plugin.settings.python_path).onChange(async (value) => {
      this.plugin.settings.python_path = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Embedding Model").setDesc("The model to use for vectorization.").addDropdown((dropdown) => dropdown.addOption("all-MiniLM-L6-v2", "all-MiniLM-L6-v2").setValue(this.plugin.settings.embedding_model).onChange(async (value) => {
      this.plugin.settings.embedding_model = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from indexing (one per line).").addTextArea((text) => text.setPlaceholder("e.g. private/\ntemplates/").setValue(this.plugin.settings.excluded_folders.join("\n")).onChange(async (value) => {
      this.plugin.settings.excluded_folders = value.split("\n").map((v) => v.trim()).filter((v) => v);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Search default mode").setDesc("Fuse ranking profile: balanced or taxonomy").addDropdown((drop) => drop.addOption("balanced", "balanced").addOption("taxonomy", "taxonomy").setValue(this.plugin.settings.search_default_mode || "balanced").onChange(async (value) => {
      this.plugin.settings.search_default_mode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include linked notes by default").setDesc("When enabled, search results may include linked notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.search_include_linked_default ?? true).onChange(async (value) => {
      this.plugin.settings.search_include_linked_default = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default search limit").setDesc("How many items to return by default").addText((text) => text.setPlaceholder("e.g. 20").setValue(String(this.plugin.settings.search_limit_default ?? 20)).onChange(async (value) => {
      const n = Number(value);
      this.plugin.settings.search_limit_default = isNaN(n) ? 20 : n;
      await this.plugin.saveSettings();
    }));
  }
};

// src/mcp_server.ts
var import_child_process = require("child_process");
var fs = __toESM(require("fs"), 1);
var import_path = require("path");
var MCPServer = class {
  constructor(plugin) {
    __publicField(this, "process", null);
    __publicField(this, "status", "stopped");
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  get Status() {
    return this.status;
  }
  async start() {
    console.log("[MCP Server]: Attempting to start server...");
    try {
      const settings = this.plugin.settings;
      const adapter = this.plugin.app.vault.adapter;
      const pluginDir = this.plugin.manifest.dir || "obsidian-mcp-plugin";
      const manifestPath = await adapter.getResourcePath(
        `${pluginDir}/manifest.json`
      );
      const rawPath = manifestPath.replace(
        /app:\/\/local|app:\/\/[a-zA-Z0-9-]+/,
        ""
      );
      const pluginPath = (0, import_path.dirname)(decodeURIComponent(rawPath));
      console.log(`[MCP Server]: Plugin path: ${pluginPath}`);
      const serverPath = (0, import_path.normalize)(`${pluginPath}/dist/mcp_server.js`);
      const nodePath = "node";
      console.log(
        `[MCP Server]: Attempting to start server with node.js`
      );
      console.log(`[MCP Server]: Server script path: ${serverPath}`);
      if (!fs.existsSync(serverPath)) {
        console.error(
          `[MCP Server ERROR]: Server script path does not exist: ${serverPath}`
        );
        console.error(
          `[MCP Server INFO]: Run 'npm run build:mcp' to build the server`
        );
        this.status = "error";
        return;
      }
      this.process = (0, import_child_process.spawn)(nodePath, [
        serverPath,
        "--transport",
        "stdio"
      ]);
      this.status = "running";
      this.process.stdout?.on("data", (data) => {
        console.log(`[MCP Server]: ${data}`);
      });
      this.process.stderr?.on("data", (data) => {
        this.status = "error";
        console.error(`[MCP Server ERROR]: ${data}`);
      });
      this.process.on("close", (code) => {
        this.status = "stopped";
        console.log(`[MCP Server]: Process exited with code ${code}`);
      });
    } catch (e) {
      console.error("[MCP Server CATCH]:", e);
      this.status = "error";
    }
  }
  stop() {
    if (this.process) {
      this.process.kill();
      this.process = null;
      this.status = "stopped";
      console.log("[MCP Server]: Stopped");
    }
  }
  restart() {
    this.stop();
    this.start();
  }
};

// src/indexer.ts
var Indexer = class {
  constructor(plugin, modelsPath) {
    __publicField(this, "plugin");
    __publicField(this, "worker", null);
    __publicField(this, "isIndexing", false);
    __publicField(this, "modelsPath");
    this.plugin = plugin;
    this.modelsPath = modelsPath;
  }
  async startIndexing() {
    if (this.isIndexing) {
      this.plugin.indexingView?.addLog("Indexing is already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.indexingView?.onIndexingStart();
    const pluginRelativePath = this.plugin.manifest.dir;
    if (!pluginRelativePath) {
      const errorMessage = "Plugin directory is not available. Cannot start indexing.";
      this.plugin.indexingView?.addLog(`[Indexer ERROR]: ${errorMessage}`);
      this.stopIndexing();
      return;
    }
    const pluginRootUrl = this.plugin.app.vault.adapter.getResourcePath(pluginRelativePath);
    this.plugin.indexingView?.addLog(`Plugin root URL for worker: ${pluginRootUrl}`);
    this.worker = new Worker(this.plugin.workerUrl, { type: "module" });
    this.worker.onmessage = async (event) => {
      const { type, message, processed, total, indexedFiles, error } = event.data;
      switch (type) {
        case "log":
          this.plugin.indexingView?.addLog(`[Indexer Worker]: ${message}`);
          break;
        case "progress":
          this.plugin.indexingView?.updateProgress(processed, total);
          break;
        case "result":
          await this.saveIndex(indexedFiles);
          this.plugin.indexingView?.addLog("Indexing finished successfully.");
          this.stopIndexing();
          break;
        case "error":
          this.plugin.indexingView?.addLog(`[Indexer Worker ERROR]: ${error.message}
${error.stack}`);
          this.stopIndexing();
          break;
      }
    };
    this.worker.onerror = (event) => {
      event.preventDefault();
      const errorMessage = event.message || "An unknown error occurred";
      this.plugin.indexingView?.addLog(`[Indexer Worker ERROR]: ${errorMessage}`);
      console.error("Full error event:", event);
      this.stopIndexing();
    };
    const filesToIndex = await this.prepareFiles();
    this.worker.postMessage({
      type: "start",
      files: filesToIndex,
      model: this.plugin.settings.embedding_model,
      mcpPort: this.plugin.settings.mcp_port
      // Передаем порт MCP-сервера
    });
  }
  // ВОТ ЭТОТ МЕТОД БЫЛ ПОТЕРЯН. Я ЕГО ВЕРНУЛ.
  stopIndexing() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isIndexing = false;
    this.plugin.indexingView?.onIndexingStop();
  }
  async prepareFiles() {
    const files = this.plugin.app.vault.getMarkdownFiles();
    const excludedFolders = this.plugin.settings.excluded_folders;
    const defaultExcludes = [
      ".obsidian/",
      "node_modules/",
      ".venv/",
      "venv/",
      "dist/",
      "build/"
    ];
    const filesToProcess = files.filter((file) => {
      const p = file.path;
      if (defaultExcludes.some((pref) => p.startsWith(pref) || p.includes("/" + pref)))
        return false;
      if (excludedFolders.some((folder) => p.startsWith(folder)))
        return false;
      return true;
    });
    const fileContents = await Promise.all(
      filesToProcess.map(async (file) => ({
        path: file.path,
        content: await this.plugin.app.vault.cachedRead(file)
      }))
    );
    return fileContents;
  }
  async saveIndex(indexedFiles) {
    const indexPath = `${this.plugin.app.vault.configDir}/plugins/obsidian-mcp-plugin/index.json`;
    await this.plugin.app.vault.adapter.write(indexPath, JSON.stringify(indexedFiles, null, 2));
  }
};

// src/indexing_view.ts
var import_obsidian2 = require("obsidian");
var INDEXING_VIEW_TYPE = "mcp-indexing-view";
var IndexingView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "logContainer");
    __publicField(this, "progressBar");
    this.plugin = plugin;
  }
  getViewType() {
    return INDEXING_VIEW_TYPE;
  }
  getDisplayText() {
    return "MCP Indexing";
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    container.createEl("h2", { text: "MCP Indexing Status" });
    const statusSection = container.createDiv();
    statusSection.createEl("h3", { text: "Status" });
    const controlsSection = container.createDiv();
    controlsSection.createEl("h3", { text: "Controls" });
    const startButton = controlsSection.createEl("button", { text: "Start Indexing" });
    const stopButton = controlsSection.createEl("button", { text: "Stop Indexing", attr: { disabled: "true" } });
    const restartServerButton = controlsSection.createEl("button", { text: "Restart MCP Server" });
    startButton.onClickEvent(() => this.plugin.indexer.startIndexing());
    stopButton.onClickEvent(() => this.plugin.indexer.stopIndexing());
    restartServerButton.onClickEvent(() => this.plugin.mcpServer.restart());
    const progressSection = container.createDiv();
    progressSection.createEl("h3", { text: "Progress" });
    this.progressBar = progressSection.createEl("progress");
    this.progressBar.style.width = "100%";
    const logsSection = container.createDiv();
    logsSection.createEl("h3", { text: "Logs" });
    this.logContainer = logsSection.createEl("div", { cls: "mcp-log-container" });
  }
  addLog(message) {
    const logLine = this.logContainer.createEl("div", { text: message });
    this.logContainer.scrollTop = this.logContainer.scrollHeight;
  }
  updateProgress(processed, total) {
    this.progressBar.max = total;
    this.progressBar.value = processed;
  }
  onIndexingStart() {
    this.containerEl.querySelector('button[text="Start Indexing"]')?.setAttribute("disabled", "true");
    this.containerEl.querySelector('button[text="Stop Indexing"]')?.removeAttribute("disabled");
  }
  onIndexingStop() {
    this.containerEl.querySelector('button[text="Start Indexing"]')?.removeAttribute("disabled");
    this.containerEl.querySelector('button[text="Stop Indexing"]')?.setAttribute("disabled", "true");
    this.progressBar.value = 0;
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "mcpServer");
    __publicField(this, "indexer");
    __publicField(this, "indexingView");
    __publicField(this, "workerUrl");
  }
  async onload() {
    await this.loadSettings();
    const workerPath = `${this.manifest.dir}/worker.js`;
    const workerBlob = new Blob([await this.app.vault.adapter.read(workerPath)], { type: "text/javascript" });
    this.workerUrl = URL.createObjectURL(workerBlob);
    this.mcpServer = new MCPServer(this);
    const modelsPath = `${this.manifest.dir}/models`;
    this.indexer = new Indexer(this, modelsPath);
    this.addSettingTab(new MCPSettingsTab(this.app, this));
    this.registerView(
      INDEXING_VIEW_TYPE,
      (leaf) => this.indexingView = new IndexingView(leaf, this)
    );
    this.addRibbonIcon("brain-circuit", "Activate MCP Indexing View", () => {
      this.activateView();
    });
    this.addCommand({
      id: "start-indexing",
      name: "Start Indexing",
      callback: () => {
        this.indexer.startIndexing();
      }
    });
    await this.setupPythonEnvironment();
    await this.mcpServer.start();
  }
  onunload() {
    this.mcpServer.stop();
    if (this.indexingView) {
      this.indexingView.leaf.detach();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async setupPythonEnvironment() {
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(INDEXING_VIEW_TYPE);
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: INDEXING_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3R5cGVzLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvbWNwX3NlcnZlci50cyIsICJzcmMvaW5kZXhlci50cyIsICJzcmMvaW5kZXhpbmdfdmlldy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgTUNQU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE1DUFNldHRpbmdzVGFiIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBNQ1BTZXJ2ZXIgfSBmcm9tICcuL21jcF9zZXJ2ZXInO1xuaW1wb3J0IHsgSW5kZXhlciB9IGZyb20gJy4vaW5kZXhlcic7XG5pbXBvcnQgeyBJbmRleGluZ1ZpZXcsIElOREVYSU5HX1ZJRVdfVFlQRSB9IGZyb20gJy4vaW5kZXhpbmdfdmlldyc7XG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplLCBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogTUNQU2V0dGluZ3M7XG4gICAgbWNwU2VydmVyOiBNQ1BTZXJ2ZXI7XG4gICAgaW5kZXhlcjogSW5kZXhlcjtcbiAgICBpbmRleGluZ1ZpZXc6IEluZGV4aW5nVmlldztcbiAgICB3b3JrZXJVcmw6IHN0cmluZztcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgY29uc3Qgd29ya2VyUGF0aCA9IGAke3RoaXMubWFuaWZlc3QuZGlyfS93b3JrZXIuanNgO1xuICAgICAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoW2F3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZCh3b3JrZXJQYXRoKV0sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgICAgIHRoaXMud29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcblxuICAgICAgICB0aGlzLm1jcFNlcnZlciA9IG5ldyBNQ1BTZXJ2ZXIodGhpcyk7XG4gICAgICAgIGNvbnN0IG1vZGVsc1BhdGggPSBgJHt0aGlzLm1hbmlmZXN0LmRpcn0vbW9kZWxzYDtcbiAgICAgICAgdGhpcy5pbmRleGVyID0gbmV3IEluZGV4ZXIodGhpcywgbW9kZWxzUGF0aCk7XG5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBNQ1BTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFxuICAgICAgICAgICAgSU5ERVhJTkdfVklFV19UWVBFLFxuICAgICAgICAgICAgKGxlYWYpID0+ICh0aGlzLmluZGV4aW5nVmlldyA9IG5ldyBJbmRleGluZ1ZpZXcobGVhZiwgdGhpcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdicmFpbi1jaXJjdWl0JywgJ0FjdGl2YXRlIE1DUCBJbmRleGluZyBWaWV3JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZpZXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnc3RhcnQtaW5kZXhpbmcnLFxuICAgICAgICAgICAgbmFtZTogJ1N0YXJ0IEluZGV4aW5nJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVyLnN0YXJ0SW5kZXhpbmcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0dXBQeXRob25FbnZpcm9ubWVudCgpO1xuICAgICAgICBhd2FpdCB0aGlzLm1jcFNlcnZlci5zdGFydCgpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICB0aGlzLm1jcFNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmluZGV4aW5nVmlldykge1xuICAgICAgICAgICAgdGhpcy5pbmRleGluZ1ZpZXcubGVhZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNldHVwUHl0aG9uRW52aXJvbm1lbnQoKSB7XG4gICAgICAgIC8vIC4uLlxuICAgIH1cblxuICAgIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShJTkRFWElOR19WSUVXX1RZUEUpO1xuXG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTtcbiAgICAgICAgaWYgKGxlYWYpIHtcbiAgICAgICAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTkRFWElOR19WSUVXX1RZUEUsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICB9XG4gICAgfVxufSIsICJleHBvcnQgaW50ZXJmYWNlIE1DUFNldHRpbmdzIHtcbiAgICBtY3BfcG9ydDogbnVtYmVyO1xuICAgIHB5dGhvbl9wYXRoOiBzdHJpbmc7XG4gICAgZW1iZWRkaW5nX21vZGVsOiBzdHJpbmc7XG4gICAgZXhjbHVkZWRfZm9sZGVyczogc3RyaW5nW107XG4gICAgc2VhcmNoX2RlZmF1bHRfbW9kZT86ICdiYWxhbmNlZCcgfCAndGF4b25vbXknO1xuICAgIHNlYXJjaF9pbmNsdWRlX2xpbmtlZF9kZWZhdWx0PzogYm9vbGVhbjtcbiAgICBzZWFyY2hfbGltaXRfZGVmYXVsdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE1DUFNldHRpbmdzID0ge1xuICAgIG1jcF9wb3J0OiAzMDMwLFxuICAgcHl0aG9uX3BhdGg6ICdweXRob24zJyxcbiAgICBlbWJlZGRpbmdfbW9kZWw6ICdhbGwtTWluaUxNLUw2LXYyJyxcbiAgICBleGNsdWRlZF9mb2xkZXJzOiBbXG4gICAgICAgICcuZ2l0JyxcbiAgICAgICAgJ25vZGVfbW9kdWxlcycsXG4gICAgICAgICdkaXN0JyxcbiAgICAgICAgJ2J1aWxkJyxcbiAgICAgICAgJy52ZW52JyxcbiAgICAgICAgJ3ZlbnYnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi8udmVudicsXG4gICAgICAgICcub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL3ZlbnYnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi9ub2RlX21vZHVsZXMnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi9kaXN0JyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vbW9kZWxzJyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vb25ueCcsXG4gICAgICAgICcub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL29wZW52aW5vJ1xuICAgIF0sXG4gICAgc2VhcmNoX2RlZmF1bHRfbW9kZTogJ2JhbGFuY2VkJyxcbiAgICBzZWFyY2hfaW5jbHVkZV9saW5rZWRfZGVmYXVsdDogdHJ1ZSxcbiAgICBzZWFyY2hfbGltaXRfZGVmYXVsdDogMjAsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4ZWRGaWxlIHtcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgY29udGVudF9wcmV2aWV3OiBzdHJpbmc7XG4gICAgdmVjdG9yOiBudW1iZXJbXTtcbn0iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gJy4vbWFpbic7IC8vIEFzc3VtaW5nIE15UGx1Z2luIGlzIHRoZSBuYW1lIG9mIHRoZSBtYWluIHBsdWdpbiBjbGFzc1xuXG5leHBvcnQgY2xhc3MgTUNQU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IE15UGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXlQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnTUNQIFNldHRpbmdzJyB9KTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdNQ1AgU2VydmVyIFBvcnQnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBwb3J0IGZvciB0aGUgTUNQIHNlcnZlci4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuIDMwMzAnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tY3BfcG9ydC50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWNwX3BvcnQgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnUHl0aG9uIFBhdGgnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBwYXRoIHRvIHRoZSBQeXRob24gZXhlY3V0YWJsZS4nKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuIC91c3IvYmluL3B5dGhvbjMnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25fcGF0aClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnB5dGhvbl9wYXRoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdFbWJlZGRpbmcgTW9kZWwnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1RoZSBtb2RlbCB0byB1c2UgZm9yIHZlY3Rvcml6YXRpb24uJylcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ2FsbC1NaW5pTE0tTDYtdjInLCAnYWxsLU1pbmlMTS1MNi12MicpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYmVkZGluZ19tb2RlbClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYmVkZGluZ19tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRXhjbHVkZWQgRm9sZGVycycpXG4gICAgICAgICAgICAuc2V0RGVzYygnRm9sZGVycyB0byBleGNsdWRlIGZyb20gaW5kZXhpbmcgKG9uZSBwZXIgbGluZSkuJylcbiAgICAgICAgICAgIC5hZGRUZXh0QXJlYSh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ2UuZy4gcHJpdmF0ZS9cXG50ZW1wbGF0ZXMvJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZWRfZm9sZGVycy5qb2luKCdcXG4nKSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGVkX2ZvbGRlcnMgPSB2YWx1ZS5zcGxpdCgnXFxuJykubWFwKHYgPT4gdi50cmltKCkpLmZpbHRlcih2ID0+IHYpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnU2VhcmNoIGRlZmF1bHQgbW9kZScpXG4gICAgICAgICAgICAuc2V0RGVzYygnRnVzZSByYW5raW5nIHByb2ZpbGU6IGJhbGFuY2VkIG9yIHRheG9ub215JylcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wID0+IGRyb3BcbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdiYWxhbmNlZCcsICdiYWxhbmNlZCcpXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbigndGF4b25vbXknLCAndGF4b25vbXknKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWFyY2hfZGVmYXVsdF9tb2RlIHx8ICdiYWxhbmNlZCcpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWFyY2hfZGVmYXVsdF9tb2RlID0gdmFsdWUgYXMgYW55O1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnSW5jbHVkZSBsaW5rZWQgbm90ZXMgYnkgZGVmYXVsdCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnV2hlbiBlbmFibGVkLCBzZWFyY2ggcmVzdWx0cyBtYXkgaW5jbHVkZSBsaW5rZWQgbm90ZXMnKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlYXJjaF9pbmNsdWRlX2xpbmtlZF9kZWZhdWx0ID8/IHRydWUpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWFyY2hfaW5jbHVkZV9saW5rZWRfZGVmYXVsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRGVmYXVsdCBzZWFyY2ggbGltaXQnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0hvdyBtYW55IGl0ZW1zIHRvIHJldHVybiBieSBkZWZhdWx0JylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiAyMCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWFyY2hfbGltaXRfZGVmYXVsdCA/PyAyMCkpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VhcmNoX2xpbWl0X2RlZmF1bHQgPSBpc05hTihuKSA/IDIwIDogbjtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgQ2hpbGRQcm9jZXNzLCBzcGF3biB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IE1DUFNldHRpbmdzIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5pbXBvcnQgeyBub3JtYWxpemUsIGRpcm5hbWUgfSBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgdHlwZSBTZXJ2ZXJTdGF0dXMgPSBcInJ1bm5pbmdcIiB8IFwic3RvcHBlZFwiIHwgXCJlcnJvclwiO1xuXG5leHBvcnQgY2xhc3MgTUNQU2VydmVyIHtcbiAgcHJpdmF0ZSBwcm9jZXNzOiBDaGlsZFByb2Nlc3MgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdGF0dXM6IFNlcnZlclN0YXR1cyA9IFwic3RvcHBlZFwiO1xuICBwcml2YXRlIHBsdWdpbjogTXlQbHVnaW47XG5cbiAgY29uc3RydWN0b3IocGx1Z2luOiBNeVBsdWdpbikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZ2V0IFN0YXR1cygpOiBTZXJ2ZXJTdGF0dXMge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cztcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGNvbnNvbGUubG9nKFwiW01DUCBTZXJ2ZXJdOiBBdHRlbXB0aW5nIHRvIHN0YXJ0IHNlcnZlci4uLlwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlcjtcbiAgICAgIGNvbnN0IHBsdWdpbkRpciA9IHRoaXMucGx1Z2luLm1hbmlmZXN0LmRpciB8fCBcIm9ic2lkaWFuLW1jcC1wbHVnaW5cIjtcblxuICAgICAgLy8gQSBtb3JlIHJlbGlhYmxlIHdheSB0byBnZXQgdGhlIHBsdWdpbiBwYXRoXG4gICAgICBjb25zdCBtYW5pZmVzdFBhdGggPSBhd2FpdCBhZGFwdGVyLmdldFJlc291cmNlUGF0aChcbiAgICAgICAgYCR7cGx1Z2luRGlyfS9tYW5pZmVzdC5qc29uYCxcbiAgICAgICk7XG4gICAgICBjb25zdCByYXdQYXRoID0gbWFuaWZlc3RQYXRoLnJlcGxhY2UoXG4gICAgICAgIC9hcHA6XFwvXFwvbG9jYWx8YXBwOlxcL1xcL1thLXpBLVowLTktXSsvLFxuICAgICAgICBcIlwiLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHBsdWdpblBhdGggPSBkaXJuYW1lKGRlY29kZVVSSUNvbXBvbmVudChyYXdQYXRoKSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbTUNQIFNlcnZlcl06IFBsdWdpbiBwYXRoOiAke3BsdWdpblBhdGh9YCk7XG5cbiAgICAgIGNvbnN0IHNlcnZlclBhdGggPSBub3JtYWxpemUoYCR7cGx1Z2luUGF0aH0vZGlzdC9tY3Bfc2VydmVyLmpzYCk7XG4gICAgICBjb25zdCBub2RlUGF0aCA9IFwibm9kZVwiOyAvLyBcdTA0MUZcdTA0NDBcdTA0MzVcdTA0MzRcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0MzBcdTA0MzNcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDQ3XHUwNDQyXHUwNDNFIE5vZGUuanMgXHUwNDMyIFBBVEhcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBbTUNQIFNlcnZlcl06IEF0dGVtcHRpbmcgdG8gc3RhcnQgc2VydmVyIHdpdGggbm9kZS5qc2AsXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coYFtNQ1AgU2VydmVyXTogU2VydmVyIHNjcmlwdCBwYXRoOiAke3NlcnZlclBhdGh9YCk7XG5cbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhzZXJ2ZXJQYXRoKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBbTUNQIFNlcnZlciBFUlJPUl06IFNlcnZlciBzY3JpcHQgcGF0aCBkb2VzIG5vdCBleGlzdDogJHtzZXJ2ZXJQYXRofWAsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFtNQ1AgU2VydmVyIElORk9dOiBSdW4gJ25wbSBydW4gYnVpbGQ6bWNwJyB0byBidWlsZCB0aGUgc2VydmVyYCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9jZXNzID0gc3Bhd24obm9kZVBhdGgsIFtcbiAgICAgICAgc2VydmVyUGF0aCxcbiAgICAgICAgXCItLXRyYW5zcG9ydFwiLFxuICAgICAgICBcInN0ZGlvXCJcbiAgICAgIF0pO1xuICAgICAgdGhpcy5zdGF0dXMgPSBcInJ1bm5pbmdcIjtcblxuICAgICAgdGhpcy5wcm9jZXNzLnN0ZG91dD8ub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbTUNQIFNlcnZlcl06ICR7ZGF0YX1gKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnByb2Nlc3Muc3RkZXJyPy5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtNQ1AgU2VydmVyIEVSUk9SXTogJHtkYXRhfWApO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJvY2Vzcy5vbihcImNsb3NlXCIsIChjb2RlKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gXCJzdG9wcGVkXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbTUNQIFNlcnZlcl06IFByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW01DUCBTZXJ2ZXIgQ0FUQ0hdOlwiLCBlKTtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJlcnJvclwiO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzcykge1xuICAgICAgdGhpcy5wcm9jZXNzLmtpbGwoKTtcbiAgICAgIHRoaXMucHJvY2VzcyA9IG51bGw7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwic3RvcHBlZFwiO1xuICAgICAgY29uc29sZS5sb2coXCJbTUNQIFNlcnZlcl06IFN0b3BwZWRcIik7XG4gICAgfVxuICB9XG5cbiAgcmVzdGFydCgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlLCBEYXRhQWRhcHRlciwgbm9ybWFsaXplUGF0aCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNeVBsdWdpbiBmcm9tICcuL21haW4nO1xuaW1wb3J0IHsgSW5kZXhlZEZpbGUgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEluZGV4ZXIge1xuICAgIHByaXZhdGUgcGx1Z2luOiBNeVBsdWdpbjtcbiAgICBwcml2YXRlIHdvcmtlcjogV29ya2VyIHwgbnVsbCA9IG51bGw7XG4gICAgcHVibGljIGlzSW5kZXhpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIG1vZGVsc1BhdGg6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogTXlQbHVnaW4sIG1vZGVsc1BhdGg6IHN0cmluZykge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgdGhpcy5tb2RlbHNQYXRoID0gbW9kZWxzUGF0aDsgLy8gXHUwNDJEXHUwNDQyXHUwNDNFXHUwNDQyIFx1MDQzRlx1MDQzMFx1MDQ0MFx1MDQzMFx1MDQzQ1x1MDQzNVx1MDQ0Mlx1MDQ0MCBcdTA0MzFcdTA0M0VcdTA0M0JcdTA0NENcdTA0NDhcdTA0MzUgXHUwNDNEXHUwNDM1IFx1MDQzOFx1MDQ0MVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzN1x1MDQ0M1x1MDQzNVx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0MzRcdTA0M0JcdTA0NEYgXHUwNDMyXHUwNDNFXHUwNDQwXHUwNDNBXHUwNDM1XHUwNDQwXHUwNDMwLCBcdTA0M0RcdTA0M0UgXHUwNDNFXHUwNDQxXHUwNDQyXHUwNDMwXHUwNDMyXHUwNDM4XHUwNDNDIFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0M0ZcdTA0M0VcdTA0NDBcdTA0NEZcdTA0MzRcdTA0M0FcdTA0MzBcbiAgICB9XG5cbiAgICBhc3luYyBzdGFydEluZGV4aW5nKCkge1xuICAgIGlmICh0aGlzLmlzSW5kZXhpbmcpIHtcbiAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coJ0luZGV4aW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzSW5kZXhpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8ub25JbmRleGluZ1N0YXJ0KCk7XG5cbiAgICAvLyAtLS0gXHUwNDFEXHUwNDEwXHUwNDI3XHUwNDEwXHUwNDFCXHUwNDFFIFx1MDQyNFx1MDQxOFx1MDQxRFx1MDQxMFx1MDQxQlx1MDQyQ1x1MDQxRFx1MDQxRVx1MDQxM1x1MDQxRSBcdTA0MThcdTA0MjFcdTA0MUZcdTA0MjBcdTA0MTBcdTA0MTJcdTA0MUJcdTA0MTVcdTA0MURcdTA0MThcdTA0MkYgLS0tXG5cbiAgICBjb25zdCBwbHVnaW5SZWxhdGl2ZVBhdGggPSB0aGlzLnBsdWdpbi5tYW5pZmVzdC5kaXI7XG5cbiAgICBpZiAoIXBsdWdpblJlbGF0aXZlUGF0aCkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBcIlBsdWdpbiBkaXJlY3RvcnkgaXMgbm90IGF2YWlsYWJsZS4gQ2Fubm90IHN0YXJ0IGluZGV4aW5nLlwiO1xuICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZyhgW0luZGV4ZXIgRVJST1JdOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5zdG9wSW5kZXhpbmcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGBnZXRSZXNvdXJjZVBhdGhgIFx1MDQzQVx1MDQzMFx1MDQzQSBcdTA0NDBcdTA0MzBcdTA0MzcgXHUwNDM4IFx1MDQzRVx1MDQzNlx1MDQzOFx1MDQzNFx1MDQzMFx1MDQzNVx1MDQ0MiBcdTA0M0ZcdTA0NDNcdTA0NDJcdTA0NEMgXHUwNDNFXHUwNDQyXHUwNDNEXHUwNDNFXHUwNDQxXHUwNDM4XHUwNDQyXHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDNFIFx1MDQzQVx1MDQzRVx1MDQ0MFx1MDQzRFx1MDQ0RiBcdTA0NDVcdTA0NDBcdTA0MzBcdTA0M0RcdTA0MzhcdTA0M0JcdTA0MzhcdTA0NDlcdTA0MzAuXG4gICAgLy8gYG1hbmlmZXN0LmRpcmAgXHUwNDM4XHUwNDNDXHUwNDM1XHUwNDNEXHUwNDNEXHUwNDNFIFx1MDQzNVx1MDQzM1x1MDQzRSBcdTA0MzggXHUwNDNGXHUwNDQwXHUwNDM1XHUwNDM0XHUwNDNFXHUwNDQxXHUwNDQyXHUwNDMwXHUwNDMyXHUwNDNCXHUwNDRGXHUwNDM1XHUwNDQyLlxuICAgIGNvbnN0IHBsdWdpblJvb3RVcmwgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5nZXRSZXNvdXJjZVBhdGgocGx1Z2luUmVsYXRpdmVQYXRoKTtcblxuICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8uYWRkTG9nKGBQbHVnaW4gcm9vdCBVUkwgZm9yIHdvcmtlcjogJHtwbHVnaW5Sb290VXJsfWApO1xuXG4gICAgLy8gLS0tIFx1MDQxQVx1MDQxRVx1MDQxRFx1MDQxNVx1MDQyNiBcdTA0MjRcdTA0MThcdTA0MURcdTA0MTBcdTA0MUJcdTA0MkNcdTA0MURcdTA0MUVcdTA0MTNcdTA0MUUgXHUwNDE4XHUwNDIxXHUwNDFGXHUwNDIwXHUwNDEwXHUwNDEyXHUwNDFCXHUwNDE1XHUwNDFEXHUwNDE4XHUwNDJGIC0tLVxuXG4gICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKHRoaXMucGx1Z2luLndvcmtlclVybCwgeyB0eXBlOiAnbW9kdWxlJyB9KTtcblxuICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHR5cGUsIG1lc3NhZ2UsIHByb2Nlc3NlZCwgdG90YWwsIGluZGV4ZWRGaWxlcywgZXJyb3IgfSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8uYWRkTG9nKGBbSW5kZXhlciBXb3JrZXJdOiAke21lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py51cGRhdGVQcm9ncmVzcyhwcm9jZXNzZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc3VsdCc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlSW5kZXgoaW5kZXhlZEZpbGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZygnSW5kZXhpbmcgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEluZGV4aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coYFtJbmRleGVyIFdvcmtlciBFUlJPUl06ICR7ZXJyb3IubWVzc2FnZX1cXG4ke2Vycm9yLnN0YWNrfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEluZGV4aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy53b3JrZXIub25lcnJvciA9IChldmVudDogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBldmVudC5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJztcbiAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coYFtJbmRleGVyIFdvcmtlciBFUlJPUl06ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGdWxsIGVycm9yIGV2ZW50OicsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5zdG9wSW5kZXhpbmcoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsZXNUb0luZGV4ID0gYXdhaXQgdGhpcy5wcmVwYXJlRmlsZXMoKTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdzdGFydCcsXG4gICAgICAgIGZpbGVzOiBmaWxlc1RvSW5kZXgsXG4gICAgICAgIG1vZGVsOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbWJlZGRpbmdfbW9kZWwsXG4gICAgICAgIG1jcFBvcnQ6IHRoaXMucGx1Z2luLnNldHRpbmdzLm1jcF9wb3J0LCAvLyBcdTA0MUZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzRcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDNGXHUwNDNFXHUwNDQwXHUwNDQyIE1DUC1cdTA0NDFcdTA0MzVcdTA0NDBcdTA0MzJcdTA0MzVcdTA0NDBcdTA0MzBcbiAgICB9KTtcbn1cblxuICAgIC8vIFx1MDQxMlx1MDQxRVx1MDQyMiBcdTA0MkRcdTA0MjJcdTA0MUVcdTA0MjIgXHUwNDFDXHUwNDE1XHUwNDIyXHUwNDFFXHUwNDE0IFx1MDQxMVx1MDQyQlx1MDQxQiBcdTA0MUZcdTA0MUVcdTA0MjJcdTA0MTVcdTA0MjBcdTA0MkZcdTA0MUQuIFx1MDQyRiBcdTA0MTVcdTA0MTNcdTA0MUUgXHUwNDEyXHUwNDE1XHUwNDIwXHUwNDFEXHUwNDIzXHUwNDFCLlxuICAgIHB1YmxpYyBzdG9wSW5kZXhpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0luZGV4aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8ub25JbmRleGluZ1N0b3AoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHByZXBhcmVGaWxlcygpOiBQcm9taXNlPHsgcGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgfVtdPiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICAgICAgY29uc3QgZXhjbHVkZWRGb2xkZXJzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZWRfZm9sZGVycztcblxuICAgICAgICBjb25zdCBkZWZhdWx0RXhjbHVkZXMgPSBbXG4gICAgICAgICAgICAnLm9ic2lkaWFuLycsXG4gICAgICAgICAgICAnbm9kZV9tb2R1bGVzLycsXG4gICAgICAgICAgICAnLnZlbnYvJyxcbiAgICAgICAgICAgICd2ZW52LycsXG4gICAgICAgICAgICAnZGlzdC8nLFxuICAgICAgICAgICAgJ2J1aWxkLydcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBmaWxlc1RvUHJvY2VzcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBmaWxlLnBhdGg7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdEV4Y2x1ZGVzLnNvbWUocHJlZiA9PiBwLnN0YXJ0c1dpdGgocHJlZikgfHwgcC5pbmNsdWRlcygnLycgKyBwcmVmKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZEZvbGRlcnMuc29tZShmb2xkZXIgPT4gcC5zdGFydHNXaXRoKGZvbGRlcikpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZmlsZUNvbnRlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBmaWxlc1RvUHJvY2Vzcy5tYXAoYXN5bmMgKGZpbGUpID0+ICh7XG4gICAgICAgICAgICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50cztcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHNhdmVJbmRleChpbmRleGVkRmlsZXM6IEluZGV4ZWRGaWxlW10pIHtcbiAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gYCR7dGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNvbmZpZ0Rpcn0vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL2luZGV4Lmpzb25gO1xuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci53cml0ZShpbmRleFBhdGgsIEpTT04uc3RyaW5naWZ5KGluZGV4ZWRGaWxlcywgbnVsbCwgMikpO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSAnLi9tYWluJztcblxuZXhwb3J0IGNvbnN0IElOREVYSU5HX1ZJRVdfVFlQRSA9ICdtY3AtaW5kZXhpbmctdmlldyc7XG5cbmV4cG9ydCBjbGFzcyBJbmRleGluZ1ZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XG4gICAgcHJpdmF0ZSBwbHVnaW46IE15UGx1Z2luO1xuICAgIHByaXZhdGUgbG9nQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHByb2dyZXNzQmFyOiBIVE1MUHJvZ3Jlc3NFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBNeVBsdWdpbikge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgICAgIHJldHVybiBJTkRFWElOR19WSUVXX1RZUEU7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGxheVRleHQoKSB7XG4gICAgICAgIHJldHVybiAnTUNQIEluZGV4aW5nJztcbiAgICB9XG5cbiAgICBhc3luYyBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGVudEVsO1xuICAgICAgICBjb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgY29udGFpbmVyLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ01DUCBJbmRleGluZyBTdGF0dXMnIH0pO1xuXG4gICAgICAgIC8vIFN0YXR1cyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IHN0YXR1c1NlY3Rpb24gPSBjb250YWluZXIuY3JlYXRlRGl2KCk7XG4gICAgICAgIHN0YXR1c1NlY3Rpb24uY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnU3RhdHVzJyB9KTtcbiAgICAgICAgLy8gQWRkIHN0YXR1cyBpbmRpY2F0b3JzIGhlcmUgbGF0ZXJcblxuICAgICAgICAvLyBDb250cm9scyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzU2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgY29udHJvbHNTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0NvbnRyb2xzJyB9KTtcbiAgICAgICAgY29uc3Qgc3RhcnRCdXR0b24gPSBjb250cm9sc1NlY3Rpb24uY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ1N0YXJ0IEluZGV4aW5nJyB9KTtcbiAgICAgICAgY29uc3Qgc3RvcEJ1dHRvbiA9IGNvbnRyb2xzU2VjdGlvbi5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnU3RvcCBJbmRleGluZycsIGF0dHI6IHsgZGlzYWJsZWQ6ICd0cnVlJyB9IH0pO1xuICAgICAgICBjb25zdCByZXN0YXJ0U2VydmVyQnV0dG9uID0gY29udHJvbHNTZWN0aW9uLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdSZXN0YXJ0IE1DUCBTZXJ2ZXInIH0pO1xuXG4gICAgICAgIHN0YXJ0QnV0dG9uLm9uQ2xpY2tFdmVudCgoKSA9PiB0aGlzLnBsdWdpbi5pbmRleGVyLnN0YXJ0SW5kZXhpbmcoKSk7XG4gICAgICAgIHN0b3BCdXR0b24ub25DbGlja0V2ZW50KCgpID0+IHRoaXMucGx1Z2luLmluZGV4ZXIuc3RvcEluZGV4aW5nKCkpO1xuICAgICAgICByZXN0YXJ0U2VydmVyQnV0dG9uLm9uQ2xpY2tFdmVudCgoKSA9PiB0aGlzLnBsdWdpbi5tY3BTZXJ2ZXIucmVzdGFydCgpKTtcblxuICAgICAgICAvLyBQcm9ncmVzcyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IHByb2dyZXNzU2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgcHJvZ3Jlc3NTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1Byb2dyZXNzJyB9KTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0JhciA9IHByb2dyZXNzU2VjdGlvbi5jcmVhdGVFbCgncHJvZ3Jlc3MnKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcxMDAlJztcblxuICAgICAgICAvLyBMb2dzIHNlY3Rpb25cbiAgICAgICAgY29uc3QgbG9nc1NlY3Rpb24gPSBjb250YWluZXIuY3JlYXRlRGl2KCk7XG4gICAgICAgIGxvZ3NTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0xvZ3MnIH0pO1xuICAgICAgICB0aGlzLmxvZ0NvbnRhaW5lciA9IGxvZ3NTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ21jcC1sb2ctY29udGFpbmVyJyB9KTtcbiAgICB9XG5cbiAgICBhZGRMb2cobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xpbmUgPSB0aGlzLmxvZ0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiBtZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgdXBkYXRlUHJvZ3Jlc3MocHJvY2Vzc2VkOiBudW1iZXIsIHRvdGFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5tYXggPSB0b3RhbDtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBvbkluZGV4aW5nU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignYnV0dG9uW3RleHQ9XCJTdGFydCBJbmRleGluZ1wiXScpPy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCdidXR0b25bdGV4dD1cIlN0b3AgSW5kZXhpbmdcIl0nKT8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIG9uSW5kZXhpbmdTdG9wKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvblt0ZXh0PVwiU3RhcnQgSW5kZXhpbmdcIl0nKT8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvblt0ZXh0PVwiU3RvcCBJbmRleGluZ1wiXScpPy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZSA9IDA7XG4gICAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7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
