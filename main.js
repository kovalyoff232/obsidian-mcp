/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  mcp_port: 3030,
  python_path: "python3",
  embedding_model: "all-MiniLM-L6-v2",
  excluded_folders: [
    ".git",
    "node_modules",
    "dist",
    "build",
    ".venv",
    "venv",
    ".obsidian/plugins/obsidian-mcp-plugin/.venv",
    ".obsidian/plugins/obsidian-mcp-plugin/venv",
    ".obsidian/plugins/obsidian-mcp-plugin/node_modules",
    ".obsidian/plugins/obsidian-mcp-plugin/dist",
    ".obsidian/plugins/obsidian-mcp-plugin/models",
    ".obsidian/plugins/obsidian-mcp-plugin/onnx",
    ".obsidian/plugins/obsidian-mcp-plugin/openvino"
  ]
};

// src/settings.ts
var import_obsidian = require("obsidian");
var MCPSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "MCP Settings" });
    new import_obsidian.Setting(containerEl).setName("MCP Server Port").setDesc("The port for the MCP server.").addText((text) => text.setPlaceholder("e.g. 3030").setValue(this.plugin.settings.mcp_port.toString()).onChange(async (value) => {
      this.plugin.settings.mcp_port = Number(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Python Path").setDesc("The path to the Python executable.").addText((text) => text.setPlaceholder("e.g. /usr/bin/python3").setValue(this.plugin.settings.python_path).onChange(async (value) => {
      this.plugin.settings.python_path = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Embedding Model").setDesc("The model to use for vectorization.").addDropdown((dropdown) => dropdown.addOption("all-MiniLM-L6-v2", "all-MiniLM-L6-v2").setValue(this.plugin.settings.embedding_model).onChange(async (value) => {
      this.plugin.settings.embedding_model = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from indexing (one per line).").addTextArea((text) => text.setPlaceholder("e.g. private/\ntemplates/").setValue(this.plugin.settings.excluded_folders.join("\n")).onChange(async (value) => {
      this.plugin.settings.excluded_folders = value.split("\n").map((v) => v.trim()).filter((v) => v);
      await this.plugin.saveSettings();
    }));
  }
};

// src/mcp_server.ts
var import_child_process = require("child_process");
var fs = __toESM(require("fs"), 1);
var import_path = require("path");
var MCPServer = class {
  constructor(plugin) {
    __publicField(this, "process", null);
    __publicField(this, "status", "stopped");
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  get Status() {
    return this.status;
  }
  async start() {
    console.log("[MCP Server]: Attempting to start server...");
    try {
      const settings = this.plugin.settings;
      const adapter = this.plugin.app.vault.adapter;
      const pluginDir = this.plugin.manifest.dir || "obsidian-mcp-plugin";
      const manifestPath = await adapter.getResourcePath(
        `${pluginDir}/manifest.json`
      );
      const rawPath = manifestPath.replace(
        /app:\/\/local|app:\/\/[a-zA-Z0-9-]+/,
        ""
      );
      const pluginPath = (0, import_path.dirname)(decodeURIComponent(rawPath));
      console.log(`[MCP Server]: Plugin path: ${pluginPath}`);
      const serverPath = (0, import_path.normalize)(`${pluginPath}/dist/mcp_server.js`);
      const nodePath = "node";
      console.log(
        `[MCP Server]: Attempting to start server with node.js`
      );
      console.log(`[MCP Server]: Server script path: ${serverPath}`);
      if (!fs.existsSync(serverPath)) {
        console.error(
          `[MCP Server ERROR]: Server script path does not exist: ${serverPath}`
        );
        console.error(
          `[MCP Server INFO]: Run 'npm run build:mcp' to build the server`
        );
        this.status = "error";
        return;
      }
      this.process = (0, import_child_process.spawn)(nodePath, [
        serverPath,
        "--transport",
        "stdio"
      ]);
      this.status = "running";
      this.process.stdout?.on("data", (data) => {
        console.log(`[MCP Server]: ${data}`);
      });
      this.process.stderr?.on("data", (data) => {
        this.status = "error";
        console.error(`[MCP Server ERROR]: ${data}`);
      });
      this.process.on("close", (code) => {
        this.status = "stopped";
        console.log(`[MCP Server]: Process exited with code ${code}`);
      });
    } catch (e) {
      console.error("[MCP Server CATCH]:", e);
      this.status = "error";
    }
  }
  stop() {
    if (this.process) {
      this.process.kill();
      this.process = null;
      this.status = "stopped";
      console.log("[MCP Server]: Stopped");
    }
  }
  restart() {
    this.stop();
    this.start();
  }
};

// src/indexer.ts
var Indexer = class {
  constructor(plugin, modelsPath) {
    __publicField(this, "plugin");
    __publicField(this, "worker", null);
    __publicField(this, "isIndexing", false);
    __publicField(this, "modelsPath");
    this.plugin = plugin;
    this.modelsPath = modelsPath;
  }
  async startIndexing() {
    if (this.isIndexing) {
      this.plugin.indexingView?.addLog("Indexing is already in progress.");
      return;
    }
    this.isIndexing = true;
    this.plugin.indexingView?.onIndexingStart();
    const pluginRelativePath = this.plugin.manifest.dir;
    if (!pluginRelativePath) {
      const errorMessage = "Plugin directory is not available. Cannot start indexing.";
      this.plugin.indexingView?.addLog(`[Indexer ERROR]: ${errorMessage}`);
      this.stopIndexing();
      return;
    }
    const pluginRootUrl = this.plugin.app.vault.adapter.getResourcePath(pluginRelativePath);
    this.plugin.indexingView?.addLog(`Plugin root URL for worker: ${pluginRootUrl}`);
    this.worker = new Worker(this.plugin.workerUrl, { type: "module" });
    this.worker.onmessage = async (event) => {
      const { type, message, processed, total, indexedFiles, error } = event.data;
      switch (type) {
        case "log":
          this.plugin.indexingView?.addLog(`[Indexer Worker]: ${message}`);
          break;
        case "progress":
          this.plugin.indexingView?.updateProgress(processed, total);
          break;
        case "result":
          await this.saveIndex(indexedFiles);
          this.plugin.indexingView?.addLog("Indexing finished successfully.");
          this.stopIndexing();
          break;
        case "error":
          this.plugin.indexingView?.addLog(`[Indexer Worker ERROR]: ${error.message}
${error.stack}`);
          this.stopIndexing();
          break;
      }
    };
    this.worker.onerror = (event) => {
      event.preventDefault();
      const errorMessage = event.message || "An unknown error occurred";
      this.plugin.indexingView?.addLog(`[Indexer Worker ERROR]: ${errorMessage}`);
      console.error("Full error event:", event);
      this.stopIndexing();
    };
    const filesToIndex = await this.prepareFiles();
    this.worker.postMessage({
      type: "start",
      files: filesToIndex,
      model: this.plugin.settings.embedding_model,
      mcpPort: this.plugin.settings.mcp_port
      // Передаем порт MCP-сервера
    });
  }
  // ВОТ ЭТОТ МЕТОД БЫЛ ПОТЕРЯН. Я ЕГО ВЕРНУЛ.
  stopIndexing() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.isIndexing = false;
    this.plugin.indexingView?.onIndexingStop();
  }
  async prepareFiles() {
    const files = this.plugin.app.vault.getMarkdownFiles();
    const excludedFolders = this.plugin.settings.excluded_folders;
    const defaultExcludes = [
      ".obsidian/",
      "node_modules/",
      ".venv/",
      "venv/",
      "dist/",
      "build/"
    ];
    const filesToProcess = files.filter((file) => {
      const p = file.path;
      if (defaultExcludes.some((pref) => p.startsWith(pref) || p.includes("/" + pref)))
        return false;
      if (excludedFolders.some((folder) => p.startsWith(folder)))
        return false;
      return true;
    });
    const fileContents = await Promise.all(
      filesToProcess.map(async (file) => ({
        path: file.path,
        content: await this.plugin.app.vault.cachedRead(file)
      }))
    );
    return fileContents;
  }
  async saveIndex(indexedFiles) {
    const indexPath = `${this.plugin.app.vault.configDir}/plugins/obsidian-mcp-plugin/index.json`;
    await this.plugin.app.vault.adapter.write(indexPath, JSON.stringify(indexedFiles, null, 2));
  }
};

// src/indexing_view.ts
var import_obsidian2 = require("obsidian");
var INDEXING_VIEW_TYPE = "mcp-indexing-view";
var IndexingView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "logContainer");
    __publicField(this, "progressBar");
    this.plugin = plugin;
  }
  getViewType() {
    return INDEXING_VIEW_TYPE;
  }
  getDisplayText() {
    return "MCP Indexing";
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    container.createEl("h2", { text: "MCP Indexing Status" });
    const statusSection = container.createDiv();
    statusSection.createEl("h3", { text: "Status" });
    const controlsSection = container.createDiv();
    controlsSection.createEl("h3", { text: "Controls" });
    const startButton = controlsSection.createEl("button", { text: "Start Indexing" });
    const stopButton = controlsSection.createEl("button", { text: "Stop Indexing", attr: { disabled: "true" } });
    const restartServerButton = controlsSection.createEl("button", { text: "Restart MCP Server" });
    startButton.onClickEvent(() => this.plugin.indexer.startIndexing());
    stopButton.onClickEvent(() => this.plugin.indexer.stopIndexing());
    restartServerButton.onClickEvent(() => this.plugin.mcpServer.restart());
    const progressSection = container.createDiv();
    progressSection.createEl("h3", { text: "Progress" });
    this.progressBar = progressSection.createEl("progress");
    this.progressBar.style.width = "100%";
    const logsSection = container.createDiv();
    logsSection.createEl("h3", { text: "Logs" });
    this.logContainer = logsSection.createEl("div", { cls: "mcp-log-container" });
  }
  addLog(message) {
    const logLine = this.logContainer.createEl("div", { text: message });
    this.logContainer.scrollTop = this.logContainer.scrollHeight;
  }
  updateProgress(processed, total) {
    this.progressBar.max = total;
    this.progressBar.value = processed;
  }
  onIndexingStart() {
    this.containerEl.querySelector('button[text="Start Indexing"]')?.setAttribute("disabled", "true");
    this.containerEl.querySelector('button[text="Stop Indexing"]')?.removeAttribute("disabled");
  }
  onIndexingStop() {
    this.containerEl.querySelector('button[text="Start Indexing"]')?.removeAttribute("disabled");
    this.containerEl.querySelector('button[text="Stop Indexing"]')?.setAttribute("disabled", "true");
    this.progressBar.value = 0;
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "mcpServer");
    __publicField(this, "indexer");
    __publicField(this, "indexingView");
    __publicField(this, "workerUrl");
  }
  async onload() {
    await this.loadSettings();
    const workerPath = `${this.manifest.dir}/worker.js`;
    const workerBlob = new Blob([await this.app.vault.adapter.read(workerPath)], { type: "text/javascript" });
    this.workerUrl = URL.createObjectURL(workerBlob);
    this.mcpServer = new MCPServer(this);
    const modelsPath = `${this.manifest.dir}/models`;
    this.indexer = new Indexer(this, modelsPath);
    this.addSettingTab(new MCPSettingsTab(this.app, this));
    this.registerView(
      INDEXING_VIEW_TYPE,
      (leaf) => this.indexingView = new IndexingView(leaf, this)
    );
    this.addRibbonIcon("brain-circuit", "Activate MCP Indexing View", () => {
      this.activateView();
    });
    this.addCommand({
      id: "start-indexing",
      name: "Start Indexing",
      callback: () => {
        this.indexer.startIndexing();
      }
    });
    await this.setupPythonEnvironment();
    await this.mcpServer.start();
  }
  onunload() {
    this.mcpServer.stop();
    if (this.indexingView) {
      this.indexingView.leaf.detach();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async setupPythonEnvironment() {
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(INDEXING_VIEW_TYPE);
    const leaf = this.app.workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: INDEXING_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(leaf);
    }
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3R5cGVzLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvbWNwX3NlcnZlci50cyIsICJzcmMvaW5kZXhlci50cyIsICJzcmMvaW5kZXhpbmdfdmlldy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgTUNQU2V0dGluZ3MsIERFRkFVTFRfU0VUVElOR1MgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IE1DUFNldHRpbmdzVGFiIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBNQ1BTZXJ2ZXIgfSBmcm9tICcuL21jcF9zZXJ2ZXInO1xuaW1wb3J0IHsgSW5kZXhlciB9IGZyb20gJy4vaW5kZXhlcic7XG5pbXBvcnQgeyBJbmRleGluZ1ZpZXcsIElOREVYSU5HX1ZJRVdfVFlQRSB9IGZyb20gJy4vaW5kZXhpbmdfdmlldyc7XG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplLCBkaXJuYW1lIH0gZnJvbSAncGF0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogTUNQU2V0dGluZ3M7XG4gICAgbWNwU2VydmVyOiBNQ1BTZXJ2ZXI7XG4gICAgaW5kZXhlcjogSW5kZXhlcjtcbiAgICBpbmRleGluZ1ZpZXc6IEluZGV4aW5nVmlldztcbiAgICB3b3JrZXJVcmw6IHN0cmluZztcblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgY29uc3Qgd29ya2VyUGF0aCA9IGAke3RoaXMubWFuaWZlc3QuZGlyfS93b3JrZXIuanNgO1xuICAgICAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoW2F3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZCh3b3JrZXJQYXRoKV0sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgICAgIHRoaXMud29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcblxuICAgICAgICB0aGlzLm1jcFNlcnZlciA9IG5ldyBNQ1BTZXJ2ZXIodGhpcyk7XG4gICAgICAgIGNvbnN0IG1vZGVsc1BhdGggPSBgJHt0aGlzLm1hbmlmZXN0LmRpcn0vbW9kZWxzYDtcbiAgICAgICAgdGhpcy5pbmRleGVyID0gbmV3IEluZGV4ZXIodGhpcywgbW9kZWxzUGF0aCk7XG5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBNQ1BTZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFxuICAgICAgICAgICAgSU5ERVhJTkdfVklFV19UWVBFLFxuICAgICAgICAgICAgKGxlYWYpID0+ICh0aGlzLmluZGV4aW5nVmlldyA9IG5ldyBJbmRleGluZ1ZpZXcobGVhZiwgdGhpcykpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdicmFpbi1jaXJjdWl0JywgJ0FjdGl2YXRlIE1DUCBJbmRleGluZyBWaWV3JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZpZXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAnc3RhcnQtaW5kZXhpbmcnLFxuICAgICAgICAgICAgbmFtZTogJ1N0YXJ0IEluZGV4aW5nJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVyLnN0YXJ0SW5kZXhpbmcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc2V0dXBQeXRob25FbnZpcm9ubWVudCgpO1xuICAgICAgICBhd2FpdCB0aGlzLm1jcFNlcnZlci5zdGFydCgpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICB0aGlzLm1jcFNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmluZGV4aW5nVmlldykge1xuICAgICAgICAgICAgdGhpcy5pbmRleGluZ1ZpZXcubGVhZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNldHVwUHl0aG9uRW52aXJvbm1lbnQoKSB7XG4gICAgICAgIC8vIC4uLlxuICAgIH1cblxuICAgIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmRldGFjaExlYXZlc09mVHlwZShJTkRFWElOR19WSUVXX1RZUEUpO1xuXG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTtcbiAgICAgICAgaWYgKGxlYWYpIHtcbiAgICAgICAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTkRFWElOR19WSUVXX1RZUEUsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICB9XG4gICAgfVxufSIsICJleHBvcnQgaW50ZXJmYWNlIE1DUFNldHRpbmdzIHtcbiAgICBtY3BfcG9ydDogbnVtYmVyO1xuICAgIHB5dGhvbl9wYXRoOiBzdHJpbmc7XG4gICAgZW1iZWRkaW5nX21vZGVsOiBzdHJpbmc7XG4gICAgZXhjbHVkZWRfZm9sZGVyczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNQ1BTZXR0aW5ncyA9IHtcbiAgICBtY3BfcG9ydDogMzAzMCxcbiAgIHB5dGhvbl9wYXRoOiAncHl0aG9uMycsXG4gICAgZW1iZWRkaW5nX21vZGVsOiAnYWxsLU1pbmlMTS1MNi12MicsXG4gICAgZXhjbHVkZWRfZm9sZGVyczogW1xuICAgICAgICAnLmdpdCcsXG4gICAgICAgICdub2RlX21vZHVsZXMnLFxuICAgICAgICAnZGlzdCcsXG4gICAgICAgICdidWlsZCcsXG4gICAgICAgICcudmVudicsXG4gICAgICAgICd2ZW52JyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vLnZlbnYnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi92ZW52JyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vbm9kZV9tb2R1bGVzJyxcbiAgICAgICAgJy5vYnNpZGlhbi9wbHVnaW5zL29ic2lkaWFuLW1jcC1wbHVnaW4vZGlzdCcsXG4gICAgICAgICcub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL21vZGVscycsXG4gICAgICAgICcub2JzaWRpYW4vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL29ubngnLFxuICAgICAgICAnLm9ic2lkaWFuL3BsdWdpbnMvb2JzaWRpYW4tbWNwLXBsdWdpbi9vcGVudmlubydcbiAgICBdLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBJbmRleGVkRmlsZSB7XG4gICAgcGF0aDogc3RyaW5nO1xuICAgIGNvbnRlbnRfcHJldmlldzogc3RyaW5nO1xuICAgIHZlY3RvcjogbnVtYmVyW107XG59IiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNeVBsdWdpbiBmcm9tICcuL21haW4nOyAvLyBBc3N1bWluZyBNeVBsdWdpbiBpcyB0aGUgbmFtZSBvZiB0aGUgbWFpbiBwbHVnaW4gY2xhc3NcblxuZXhwb3J0IGNsYXNzIE1DUFNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgcGx1Z2luOiBNeVBsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuICAgICAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ01DUCBTZXR0aW5ncycgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnTUNQIFNlcnZlciBQb3J0JylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgcG9ydCBmb3IgdGhlIE1DUCBzZXJ2ZXIuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiAzMDMwJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWNwX3BvcnQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1jcF9wb3J0ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1B5dGhvbiBQYXRoJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgcGF0aCB0byB0aGUgUHl0aG9uIGV4ZWN1dGFibGUuJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignZS5nLiAvdXNyL2Jpbi9weXRob24zJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHl0aG9uX3BhdGgpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25fcGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSgnRW1iZWRkaW5nIE1vZGVsJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdUaGUgbW9kZWwgdG8gdXNlIGZvciB2ZWN0b3JpemF0aW9uLicpXG4gICAgICAgICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cbiAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKCdhbGwtTWluaUxNLUw2LXYyJywgJ2FsbC1NaW5pTE0tTDYtdjInKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbWJlZGRpbmdfbW9kZWwpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbWJlZGRpbmdfbW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0V4Y2x1ZGVkIEZvbGRlcnMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ0ZvbGRlcnMgdG8gZXhjbHVkZSBmcm9tIGluZGV4aW5nIChvbmUgcGVyIGxpbmUpLicpXG4gICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdlLmcuIHByaXZhdGUvXFxudGVtcGxhdGVzLycpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmV4Y2x1ZGVkX2ZvbGRlcnMuam9pbignXFxuJykpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlZF9mb2xkZXJzID0gdmFsdWUuc3BsaXQoJ1xcbicpLm1hcCh2ID0+IHYudHJpbSgpKS5maWx0ZXIodiA9PiB2KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgQ2hpbGRQcm9jZXNzLCBzcGF3biB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IE1DUFNldHRpbmdzIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5pbXBvcnQgeyBub3JtYWxpemUsIGRpcm5hbWUgfSBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgdHlwZSBTZXJ2ZXJTdGF0dXMgPSBcInJ1bm5pbmdcIiB8IFwic3RvcHBlZFwiIHwgXCJlcnJvclwiO1xuXG5leHBvcnQgY2xhc3MgTUNQU2VydmVyIHtcbiAgcHJpdmF0ZSBwcm9jZXNzOiBDaGlsZFByb2Nlc3MgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdGF0dXM6IFNlcnZlclN0YXR1cyA9IFwic3RvcHBlZFwiO1xuICBwcml2YXRlIHBsdWdpbjogTXlQbHVnaW47XG5cbiAgY29uc3RydWN0b3IocGx1Z2luOiBNeVBsdWdpbikge1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZ2V0IFN0YXR1cygpOiBTZXJ2ZXJTdGF0dXMge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cztcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGNvbnNvbGUubG9nKFwiW01DUCBTZXJ2ZXJdOiBBdHRlbXB0aW5nIHRvIHN0YXJ0IHNlcnZlci4uLlwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlcjtcbiAgICAgIGNvbnN0IHBsdWdpbkRpciA9IHRoaXMucGx1Z2luLm1hbmlmZXN0LmRpciB8fCBcIm9ic2lkaWFuLW1jcC1wbHVnaW5cIjtcblxuICAgICAgLy8gQSBtb3JlIHJlbGlhYmxlIHdheSB0byBnZXQgdGhlIHBsdWdpbiBwYXRoXG4gICAgICBjb25zdCBtYW5pZmVzdFBhdGggPSBhd2FpdCBhZGFwdGVyLmdldFJlc291cmNlUGF0aChcbiAgICAgICAgYCR7cGx1Z2luRGlyfS9tYW5pZmVzdC5qc29uYCxcbiAgICAgICk7XG4gICAgICBjb25zdCByYXdQYXRoID0gbWFuaWZlc3RQYXRoLnJlcGxhY2UoXG4gICAgICAgIC9hcHA6XFwvXFwvbG9jYWx8YXBwOlxcL1xcL1thLXpBLVowLTktXSsvLFxuICAgICAgICBcIlwiLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHBsdWdpblBhdGggPSBkaXJuYW1lKGRlY29kZVVSSUNvbXBvbmVudChyYXdQYXRoKSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbTUNQIFNlcnZlcl06IFBsdWdpbiBwYXRoOiAke3BsdWdpblBhdGh9YCk7XG5cbiAgICAgIGNvbnN0IHNlcnZlclBhdGggPSBub3JtYWxpemUoYCR7cGx1Z2luUGF0aH0vZGlzdC9tY3Bfc2VydmVyLmpzYCk7XG4gICAgICBjb25zdCBub2RlUGF0aCA9IFwibm9kZVwiOyAvLyBcdTA0MUZcdTA0NDBcdTA0MzVcdTA0MzRcdTA0M0ZcdTA0M0VcdTA0M0JcdTA0MzBcdTA0MzNcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDQ3XHUwNDQyXHUwNDNFIE5vZGUuanMgXHUwNDMyIFBBVEhcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBbTUNQIFNlcnZlcl06IEF0dGVtcHRpbmcgdG8gc3RhcnQgc2VydmVyIHdpdGggbm9kZS5qc2AsXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coYFtNQ1AgU2VydmVyXTogU2VydmVyIHNjcmlwdCBwYXRoOiAke3NlcnZlclBhdGh9YCk7XG5cbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhzZXJ2ZXJQYXRoKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBbTUNQIFNlcnZlciBFUlJPUl06IFNlcnZlciBzY3JpcHQgcGF0aCBkb2VzIG5vdCBleGlzdDogJHtzZXJ2ZXJQYXRofWAsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFtNQ1AgU2VydmVyIElORk9dOiBSdW4gJ25wbSBydW4gYnVpbGQ6bWNwJyB0byBidWlsZCB0aGUgc2VydmVyYCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9jZXNzID0gc3Bhd24obm9kZVBhdGgsIFtcbiAgICAgICAgc2VydmVyUGF0aCxcbiAgICAgICAgXCItLXRyYW5zcG9ydFwiLFxuICAgICAgICBcInN0ZGlvXCJcbiAgICAgIF0pO1xuICAgICAgdGhpcy5zdGF0dXMgPSBcInJ1bm5pbmdcIjtcblxuICAgICAgdGhpcy5wcm9jZXNzLnN0ZG91dD8ub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbTUNQIFNlcnZlcl06ICR7ZGF0YX1gKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnByb2Nlc3Muc3RkZXJyPy5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtNQ1AgU2VydmVyIEVSUk9SXTogJHtkYXRhfWApO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJvY2Vzcy5vbihcImNsb3NlXCIsIChjb2RlKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gXCJzdG9wcGVkXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbTUNQIFNlcnZlcl06IFByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW01DUCBTZXJ2ZXIgQ0FUQ0hdOlwiLCBlKTtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJlcnJvclwiO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzcykge1xuICAgICAgdGhpcy5wcm9jZXNzLmtpbGwoKTtcbiAgICAgIHRoaXMucHJvY2VzcyA9IG51bGw7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwic3RvcHBlZFwiO1xuICAgICAgY29uc29sZS5sb2coXCJbTUNQIFNlcnZlcl06IFN0b3BwZWRcIik7XG4gICAgfVxuICB9XG5cbiAgcmVzdGFydCgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlLCBEYXRhQWRhcHRlciwgbm9ybWFsaXplUGF0aCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBNeVBsdWdpbiBmcm9tICcuL21haW4nO1xuaW1wb3J0IHsgSW5kZXhlZEZpbGUgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEluZGV4ZXIge1xuICAgIHByaXZhdGUgcGx1Z2luOiBNeVBsdWdpbjtcbiAgICBwcml2YXRlIHdvcmtlcjogV29ya2VyIHwgbnVsbCA9IG51bGw7XG4gICAgcHVibGljIGlzSW5kZXhpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIG1vZGVsc1BhdGg6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogTXlQbHVnaW4sIG1vZGVsc1BhdGg6IHN0cmluZykge1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgdGhpcy5tb2RlbHNQYXRoID0gbW9kZWxzUGF0aDsgLy8gXHUwNDJEXHUwNDQyXHUwNDNFXHUwNDQyIFx1MDQzRlx1MDQzMFx1MDQ0MFx1MDQzMFx1MDQzQ1x1MDQzNVx1MDQ0Mlx1MDQ0MCBcdTA0MzFcdTA0M0VcdTA0M0JcdTA0NENcdTA0NDhcdTA0MzUgXHUwNDNEXHUwNDM1IFx1MDQzOFx1MDQ0MVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzN1x1MDQ0M1x1MDQzNVx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0MzRcdTA0M0JcdTA0NEYgXHUwNDMyXHUwNDNFXHUwNDQwXHUwNDNBXHUwNDM1XHUwNDQwXHUwNDMwLCBcdTA0M0RcdTA0M0UgXHUwNDNFXHUwNDQxXHUwNDQyXHUwNDMwXHUwNDMyXHUwNDM4XHUwNDNDIFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0M0ZcdTA0M0VcdTA0NDBcdTA0NEZcdTA0MzRcdTA0M0FcdTA0MzBcbiAgICB9XG5cbiAgICBhc3luYyBzdGFydEluZGV4aW5nKCkge1xuICAgIGlmICh0aGlzLmlzSW5kZXhpbmcpIHtcbiAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coJ0luZGV4aW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzSW5kZXhpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8ub25JbmRleGluZ1N0YXJ0KCk7XG5cbiAgICAvLyAtLS0gXHUwNDFEXHUwNDEwXHUwNDI3XHUwNDEwXHUwNDFCXHUwNDFFIFx1MDQyNFx1MDQxOFx1MDQxRFx1MDQxMFx1MDQxQlx1MDQyQ1x1MDQxRFx1MDQxRVx1MDQxM1x1MDQxRSBcdTA0MThcdTA0MjFcdTA0MUZcdTA0MjBcdTA0MTBcdTA0MTJcdTA0MUJcdTA0MTVcdTA0MURcdTA0MThcdTA0MkYgLS0tXG5cbiAgICBjb25zdCBwbHVnaW5SZWxhdGl2ZVBhdGggPSB0aGlzLnBsdWdpbi5tYW5pZmVzdC5kaXI7XG5cbiAgICBpZiAoIXBsdWdpblJlbGF0aXZlUGF0aCkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBcIlBsdWdpbiBkaXJlY3RvcnkgaXMgbm90IGF2YWlsYWJsZS4gQ2Fubm90IHN0YXJ0IGluZGV4aW5nLlwiO1xuICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZyhgW0luZGV4ZXIgRVJST1JdOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5zdG9wSW5kZXhpbmcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGBnZXRSZXNvdXJjZVBhdGhgIFx1MDQzQVx1MDQzMFx1MDQzQSBcdTA0NDBcdTA0MzBcdTA0MzcgXHUwNDM4IFx1MDQzRVx1MDQzNlx1MDQzOFx1MDQzNFx1MDQzMFx1MDQzNVx1MDQ0MiBcdTA0M0ZcdTA0NDNcdTA0NDJcdTA0NEMgXHUwNDNFXHUwNDQyXHUwNDNEXHUwNDNFXHUwNDQxXHUwNDM4XHUwNDQyXHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDNFIFx1MDQzQVx1MDQzRVx1MDQ0MFx1MDQzRFx1MDQ0RiBcdTA0NDVcdTA0NDBcdTA0MzBcdTA0M0RcdTA0MzhcdTA0M0JcdTA0MzhcdTA0NDlcdTA0MzAuXG4gICAgLy8gYG1hbmlmZXN0LmRpcmAgXHUwNDM4XHUwNDNDXHUwNDM1XHUwNDNEXHUwNDNEXHUwNDNFIFx1MDQzNVx1MDQzM1x1MDQzRSBcdTA0MzggXHUwNDNGXHUwNDQwXHUwNDM1XHUwNDM0XHUwNDNFXHUwNDQxXHUwNDQyXHUwNDMwXHUwNDMyXHUwNDNCXHUwNDRGXHUwNDM1XHUwNDQyLlxuICAgIGNvbnN0IHBsdWdpblJvb3RVcmwgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5nZXRSZXNvdXJjZVBhdGgocGx1Z2luUmVsYXRpdmVQYXRoKTtcblxuICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8uYWRkTG9nKGBQbHVnaW4gcm9vdCBVUkwgZm9yIHdvcmtlcjogJHtwbHVnaW5Sb290VXJsfWApO1xuXG4gICAgLy8gLS0tIFx1MDQxQVx1MDQxRVx1MDQxRFx1MDQxNVx1MDQyNiBcdTA0MjRcdTA0MThcdTA0MURcdTA0MTBcdTA0MUJcdTA0MkNcdTA0MURcdTA0MUVcdTA0MTNcdTA0MUUgXHUwNDE4XHUwNDIxXHUwNDFGXHUwNDIwXHUwNDEwXHUwNDEyXHUwNDFCXHUwNDE1XHUwNDFEXHUwNDE4XHUwNDJGIC0tLVxuXG4gICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKHRoaXMucGx1Z2luLndvcmtlclVybCwgeyB0eXBlOiAnbW9kdWxlJyB9KTtcblxuICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHR5cGUsIG1lc3NhZ2UsIHByb2Nlc3NlZCwgdG90YWwsIGluZGV4ZWRGaWxlcywgZXJyb3IgfSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8uYWRkTG9nKGBbSW5kZXhlciBXb3JrZXJdOiAke21lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcm9ncmVzcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py51cGRhdGVQcm9ncmVzcyhwcm9jZXNzZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc3VsdCc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zYXZlSW5kZXgoaW5kZXhlZEZpbGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5pbmRleGluZ1ZpZXc/LmFkZExvZygnSW5kZXhpbmcgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEluZGV4aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coYFtJbmRleGVyIFdvcmtlciBFUlJPUl06ICR7ZXJyb3IubWVzc2FnZX1cXG4ke2Vycm9yLnN0YWNrfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEluZGV4aW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy53b3JrZXIub25lcnJvciA9IChldmVudDogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBldmVudC5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJztcbiAgICAgICAgdGhpcy5wbHVnaW4uaW5kZXhpbmdWaWV3Py5hZGRMb2coYFtJbmRleGVyIFdvcmtlciBFUlJPUl06ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGdWxsIGVycm9yIGV2ZW50OicsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5zdG9wSW5kZXhpbmcoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsZXNUb0luZGV4ID0gYXdhaXQgdGhpcy5wcmVwYXJlRmlsZXMoKTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdzdGFydCcsXG4gICAgICAgIGZpbGVzOiBmaWxlc1RvSW5kZXgsXG4gICAgICAgIG1vZGVsOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbWJlZGRpbmdfbW9kZWwsXG4gICAgICAgIG1jcFBvcnQ6IHRoaXMucGx1Z2luLnNldHRpbmdzLm1jcF9wb3J0LCAvLyBcdTA0MUZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzRcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDNGXHUwNDNFXHUwNDQwXHUwNDQyIE1DUC1cdTA0NDFcdTA0MzVcdTA0NDBcdTA0MzJcdTA0MzVcdTA0NDBcdTA0MzBcbiAgICB9KTtcbn1cblxuICAgIC8vIFx1MDQxMlx1MDQxRVx1MDQyMiBcdTA0MkRcdTA0MjJcdTA0MUVcdTA0MjIgXHUwNDFDXHUwNDE1XHUwNDIyXHUwNDFFXHUwNDE0IFx1MDQxMVx1MDQyQlx1MDQxQiBcdTA0MUZcdTA0MUVcdTA0MjJcdTA0MTVcdTA0MjBcdTA0MkZcdTA0MUQuIFx1MDQyRiBcdTA0MTVcdTA0MTNcdTA0MUUgXHUwNDEyXHUwNDE1XHUwNDIwXHUwNDFEXHUwNDIzXHUwNDFCLlxuICAgIHB1YmxpYyBzdG9wSW5kZXhpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0luZGV4aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGx1Z2luLmluZGV4aW5nVmlldz8ub25JbmRleGluZ1N0b3AoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHByZXBhcmVGaWxlcygpOiBQcm9taXNlPHsgcGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgfVtdPiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICAgICAgY29uc3QgZXhjbHVkZWRGb2xkZXJzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZWRfZm9sZGVycztcblxuICAgICAgICBjb25zdCBkZWZhdWx0RXhjbHVkZXMgPSBbXG4gICAgICAgICAgICAnLm9ic2lkaWFuLycsXG4gICAgICAgICAgICAnbm9kZV9tb2R1bGVzLycsXG4gICAgICAgICAgICAnLnZlbnYvJyxcbiAgICAgICAgICAgICd2ZW52LycsXG4gICAgICAgICAgICAnZGlzdC8nLFxuICAgICAgICAgICAgJ2J1aWxkLydcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBmaWxlc1RvUHJvY2VzcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBmaWxlLnBhdGg7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdEV4Y2x1ZGVzLnNvbWUocHJlZiA9PiBwLnN0YXJ0c1dpdGgocHJlZikgfHwgcC5pbmNsdWRlcygnLycgKyBwcmVmKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZEZvbGRlcnMuc29tZShmb2xkZXIgPT4gcC5zdGFydHNXaXRoKGZvbGRlcikpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZmlsZUNvbnRlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBmaWxlc1RvUHJvY2Vzcy5tYXAoYXN5bmMgKGZpbGUpID0+ICh7XG4gICAgICAgICAgICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50cztcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHNhdmVJbmRleChpbmRleGVkRmlsZXM6IEluZGV4ZWRGaWxlW10pIHtcbiAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gYCR7dGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNvbmZpZ0Rpcn0vcGx1Z2lucy9vYnNpZGlhbi1tY3AtcGx1Z2luL2luZGV4Lmpzb25gO1xuICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci53cml0ZShpbmRleFBhdGgsIEpTT04uc3RyaW5naWZ5KGluZGV4ZWRGaWxlcywgbnVsbCwgMikpO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSAnLi9tYWluJztcblxuZXhwb3J0IGNvbnN0IElOREVYSU5HX1ZJRVdfVFlQRSA9ICdtY3AtaW5kZXhpbmctdmlldyc7XG5cbmV4cG9ydCBjbGFzcyBJbmRleGluZ1ZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XG4gICAgcHJpdmF0ZSBwbHVnaW46IE15UGx1Z2luO1xuICAgIHByaXZhdGUgbG9nQ29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHByb2dyZXNzQmFyOiBIVE1MUHJvZ3Jlc3NFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBNeVBsdWdpbikge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gICAgfVxuXG4gICAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgICAgIHJldHVybiBJTkRFWElOR19WSUVXX1RZUEU7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGxheVRleHQoKSB7XG4gICAgICAgIHJldHVybiAnTUNQIEluZGV4aW5nJztcbiAgICB9XG5cbiAgICBhc3luYyBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGVudEVsO1xuICAgICAgICBjb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgY29udGFpbmVyLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ01DUCBJbmRleGluZyBTdGF0dXMnIH0pO1xuXG4gICAgICAgIC8vIFN0YXR1cyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IHN0YXR1c1NlY3Rpb24gPSBjb250YWluZXIuY3JlYXRlRGl2KCk7XG4gICAgICAgIHN0YXR1c1NlY3Rpb24uY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnU3RhdHVzJyB9KTtcbiAgICAgICAgLy8gQWRkIHN0YXR1cyBpbmRpY2F0b3JzIGhlcmUgbGF0ZXJcblxuICAgICAgICAvLyBDb250cm9scyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzU2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgY29udHJvbHNTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0NvbnRyb2xzJyB9KTtcbiAgICAgICAgY29uc3Qgc3RhcnRCdXR0b24gPSBjb250cm9sc1NlY3Rpb24uY3JlYXRlRWwoJ2J1dHRvbicsIHsgdGV4dDogJ1N0YXJ0IEluZGV4aW5nJyB9KTtcbiAgICAgICAgY29uc3Qgc3RvcEJ1dHRvbiA9IGNvbnRyb2xzU2VjdGlvbi5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiAnU3RvcCBJbmRleGluZycsIGF0dHI6IHsgZGlzYWJsZWQ6ICd0cnVlJyB9IH0pO1xuICAgICAgICBjb25zdCByZXN0YXJ0U2VydmVyQnV0dG9uID0gY29udHJvbHNTZWN0aW9uLmNyZWF0ZUVsKCdidXR0b24nLCB7IHRleHQ6ICdSZXN0YXJ0IE1DUCBTZXJ2ZXInIH0pO1xuXG4gICAgICAgIHN0YXJ0QnV0dG9uLm9uQ2xpY2tFdmVudCgoKSA9PiB0aGlzLnBsdWdpbi5pbmRleGVyLnN0YXJ0SW5kZXhpbmcoKSk7XG4gICAgICAgIHN0b3BCdXR0b24ub25DbGlja0V2ZW50KCgpID0+IHRoaXMucGx1Z2luLmluZGV4ZXIuc3RvcEluZGV4aW5nKCkpO1xuICAgICAgICByZXN0YXJ0U2VydmVyQnV0dG9uLm9uQ2xpY2tFdmVudCgoKSA9PiB0aGlzLnBsdWdpbi5tY3BTZXJ2ZXIucmVzdGFydCgpKTtcblxuICAgICAgICAvLyBQcm9ncmVzcyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IHByb2dyZXNzU2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgcHJvZ3Jlc3NTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ1Byb2dyZXNzJyB9KTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0JhciA9IHByb2dyZXNzU2VjdGlvbi5jcmVhdGVFbCgncHJvZ3Jlc3MnKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9ICcxMDAlJztcblxuICAgICAgICAvLyBMb2dzIHNlY3Rpb25cbiAgICAgICAgY29uc3QgbG9nc1NlY3Rpb24gPSBjb250YWluZXIuY3JlYXRlRGl2KCk7XG4gICAgICAgIGxvZ3NTZWN0aW9uLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0xvZ3MnIH0pO1xuICAgICAgICB0aGlzLmxvZ0NvbnRhaW5lciA9IGxvZ3NTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ21jcC1sb2ctY29udGFpbmVyJyB9KTtcbiAgICB9XG5cbiAgICBhZGRMb2cobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGxvZ0xpbmUgPSB0aGlzLmxvZ0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyB0ZXh0OiBtZXNzYWdlIH0pO1xuICAgICAgICB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLmxvZ0NvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgdXBkYXRlUHJvZ3Jlc3MocHJvY2Vzc2VkOiBudW1iZXIsIHRvdGFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5tYXggPSB0b3RhbDtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBvbkluZGV4aW5nU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignYnV0dG9uW3RleHQ9XCJTdGFydCBJbmRleGluZ1wiXScpPy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCdidXR0b25bdGV4dD1cIlN0b3AgSW5kZXhpbmdcIl0nKT8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIG9uSW5kZXhpbmdTdG9wKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvblt0ZXh0PVwiU3RhcnQgSW5kZXhpbmdcIl0nKT8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvblt0ZXh0PVwiU3RvcCBJbmRleGluZ1wiXScpPy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZSA9IDA7XG4gICAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxtQkFBdUI7OztBQ09oQixJQUFNLG1CQUFnQztBQUFBLEVBQ3pDLFVBQVU7QUFBQSxFQUNYLGFBQWE7QUFBQSxFQUNaLGlCQUFpQjtBQUFBLEVBQ2pCLGtCQUFrQjtBQUFBLElBQ2Q7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQ0o7OztBQzFCQSxzQkFBK0M7QUFHeEMsSUFBTSxpQkFBTixjQUE2QixpQ0FBaUI7QUFBQSxFQUdqRCxZQUFZLEtBQVUsUUFBa0I7QUFDcEMsVUFBTSxLQUFLLE1BQU07QUFIckI7QUFJSSxTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBRUEsVUFBZ0I7QUFDWixVQUFNLEVBQUUsWUFBWSxJQUFJO0FBRXhCLGdCQUFZLE1BQU07QUFFbEIsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsUUFBSSx3QkFBUSxXQUFXLEVBQ2xCLFFBQVEsaUJBQWlCLEVBQ3pCLFFBQVEsOEJBQThCLEVBQ3RDLFFBQVEsVUFBUSxLQUNaLGVBQWUsV0FBVyxFQUMxQixTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsU0FBUyxDQUFDLEVBQ2pELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFdBQUssT0FBTyxTQUFTLFdBQVcsT0FBTyxLQUFLO0FBQzVDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFFVixRQUFJLHdCQUFRLFdBQVcsRUFDbEIsUUFBUSxhQUFhLEVBQ3JCLFFBQVEsb0NBQW9DLEVBQzVDLFFBQVEsVUFBUSxLQUNaLGVBQWUsdUJBQXVCLEVBQ3RDLFNBQVMsS0FBSyxPQUFPLFNBQVMsV0FBVyxFQUN6QyxTQUFTLE9BQU8sVUFBVTtBQUN2QixXQUFLLE9BQU8sU0FBUyxjQUFjO0FBQ25DLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFFVixRQUFJLHdCQUFRLFdBQVcsRUFDbEIsUUFBUSxpQkFBaUIsRUFDekIsUUFBUSxxQ0FBcUMsRUFDN0MsWUFBWSxjQUFZLFNBQ3BCLFVBQVUsb0JBQW9CLGtCQUFrQixFQUNoRCxTQUFTLEtBQUssT0FBTyxTQUFTLGVBQWUsRUFDN0MsU0FBUyxPQUFPLFVBQVU7QUFDdkIsV0FBSyxPQUFPLFNBQVMsa0JBQWtCO0FBQ3ZDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFFVixRQUFJLHdCQUFRLFdBQVcsRUFDbEIsUUFBUSxrQkFBa0IsRUFDMUIsUUFBUSxrREFBa0QsRUFDMUQsWUFBWSxVQUFRLEtBQ2hCLGVBQWUsMkJBQTJCLEVBQzFDLFNBQVMsS0FBSyxPQUFPLFNBQVMsaUJBQWlCLEtBQUssSUFBSSxDQUFDLEVBQ3pELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFdBQUssT0FBTyxTQUFTLG1CQUFtQixNQUFNLE1BQU0sSUFBSSxFQUFFLElBQUksT0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLE9BQU8sT0FBSyxDQUFDO0FBQzFGLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFBQSxFQUNkO0FBQ0o7OztBQzlEQSwyQkFBb0M7QUFDcEMsU0FBb0I7QUFHcEIsa0JBQW1DO0FBSTVCLElBQU0sWUFBTixNQUFnQjtBQUFBLEVBS3JCLFlBQVksUUFBa0I7QUFKOUIsd0JBQVEsV0FBK0I7QUFDdkMsd0JBQVEsVUFBdUI7QUFDL0Isd0JBQVE7QUFHTixTQUFLLFNBQVM7QUFBQSxFQUNoQjtBQUFBLEVBRUEsSUFBSSxTQUF1QjtBQUN6QixXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQUEsRUFFQSxNQUFNLFFBQVE7QUFDWixZQUFRLElBQUksNkNBQTZDO0FBQ3pELFFBQUk7QUFDRixZQUFNLFdBQVcsS0FBSyxPQUFPO0FBQzdCLFlBQU0sVUFBVSxLQUFLLE9BQU8sSUFBSSxNQUFNO0FBQ3RDLFlBQU0sWUFBWSxLQUFLLE9BQU8sU0FBUyxPQUFPO0FBRzlDLFlBQU0sZUFBZSxNQUFNLFFBQVE7QUFBQSxRQUNqQyxHQUFHO0FBQUEsTUFDTDtBQUNBLFlBQU0sVUFBVSxhQUFhO0FBQUEsUUFDM0I7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUNBLFlBQU0saUJBQWEscUJBQVEsbUJBQW1CLE9BQU8sQ0FBQztBQUV0RCxjQUFRLElBQUksOEJBQThCLFlBQVk7QUFFdEQsWUFBTSxpQkFBYSx1QkFBVSxHQUFHLCtCQUErQjtBQUMvRCxZQUFNLFdBQVc7QUFFakIsY0FBUTtBQUFBLFFBQ047QUFBQSxNQUNGO0FBQ0EsY0FBUSxJQUFJLHFDQUFxQyxZQUFZO0FBRTdELFVBQUksQ0FBSSxjQUFXLFVBQVUsR0FBRztBQUM5QixnQkFBUTtBQUFBLFVBQ04sMERBQTBEO0FBQUEsUUFDNUQ7QUFDQSxnQkFBUTtBQUFBLFVBQ047QUFBQSxRQUNGO0FBQ0EsYUFBSyxTQUFTO0FBQ2Q7QUFBQSxNQUNGO0FBRUEsV0FBSyxjQUFVLDRCQUFNLFVBQVU7QUFBQSxRQUM3QjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRixDQUFDO0FBQ0QsV0FBSyxTQUFTO0FBRWQsV0FBSyxRQUFRLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUztBQUN4QyxnQkFBUSxJQUFJLGlCQUFpQixNQUFNO0FBQUEsTUFDckMsQ0FBQztBQUVELFdBQUssUUFBUSxRQUFRLEdBQUcsUUFBUSxDQUFDLFNBQVM7QUFDeEMsYUFBSyxTQUFTO0FBQ2QsZ0JBQVEsTUFBTSx1QkFBdUIsTUFBTTtBQUFBLE1BQzdDLENBQUM7QUFFRCxXQUFLLFFBQVEsR0FBRyxTQUFTLENBQUMsU0FBUztBQUNqQyxhQUFLLFNBQVM7QUFDZCxnQkFBUSxJQUFJLDBDQUEwQyxNQUFNO0FBQUEsTUFDOUQsQ0FBQztBQUFBLElBQ0gsU0FBUyxHQUFQO0FBQ0EsY0FBUSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RDLFdBQUssU0FBUztBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUFBLEVBRUEsT0FBTztBQUNMLFFBQUksS0FBSyxTQUFTO0FBQ2hCLFdBQUssUUFBUSxLQUFLO0FBQ2xCLFdBQUssVUFBVTtBQUNmLFdBQUssU0FBUztBQUNkLGNBQVEsSUFBSSx1QkFBdUI7QUFBQSxJQUNyQztBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDUixTQUFLLEtBQUs7QUFDVixTQUFLLE1BQU07QUFBQSxFQUNiO0FBQ0Y7OztBQzlGTyxJQUFNLFVBQU4sTUFBYztBQUFBLEVBTWpCLFlBQVksUUFBa0IsWUFBb0I7QUFMbEQsd0JBQVE7QUFDUix3QkFBUSxVQUF3QjtBQUNoQyx3QkFBTyxjQUFzQjtBQUM3Qix3QkFBUTtBQUdKLFNBQUssU0FBUztBQUNkLFNBQUssYUFBYTtBQUFBLEVBQ3RCO0FBQUEsRUFFQSxNQUFNLGdCQUFnQjtBQUN0QixRQUFJLEtBQUssWUFBWTtBQUNqQixXQUFLLE9BQU8sY0FBYyxPQUFPLGtDQUFrQztBQUNuRTtBQUFBLElBQ0o7QUFFQSxTQUFLLGFBQWE7QUFDbEIsU0FBSyxPQUFPLGNBQWMsZ0JBQWdCO0FBSTFDLFVBQU0scUJBQXFCLEtBQUssT0FBTyxTQUFTO0FBRWhELFFBQUksQ0FBQyxvQkFBb0I7QUFDckIsWUFBTSxlQUFlO0FBQ3JCLFdBQUssT0FBTyxjQUFjLE9BQU8sb0JBQW9CLGNBQWM7QUFDbkUsV0FBSyxhQUFhO0FBQ2xCO0FBQUEsSUFDSjtBQUlBLFVBQU0sZ0JBQWdCLEtBQUssT0FBTyxJQUFJLE1BQU0sUUFBUSxnQkFBZ0Isa0JBQWtCO0FBRXRGLFNBQUssT0FBTyxjQUFjLE9BQU8sK0JBQStCLGVBQWU7QUFJL0UsU0FBSyxTQUFTLElBQUksT0FBTyxLQUFLLE9BQU8sV0FBVyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRWxFLFNBQUssT0FBTyxZQUFZLE9BQU8sVUFBVTtBQUNyQyxZQUFNLEVBQUUsTUFBTSxTQUFTLFdBQVcsT0FBTyxjQUFjLE1BQU0sSUFBSSxNQUFNO0FBRXZFLGNBQVEsTUFBTTtBQUFBLFFBQ1YsS0FBSztBQUNELGVBQUssT0FBTyxjQUFjLE9BQU8scUJBQXFCLFNBQVM7QUFDL0Q7QUFBQSxRQUNKLEtBQUs7QUFDRCxlQUFLLE9BQU8sY0FBYyxlQUFlLFdBQVcsS0FBSztBQUN6RDtBQUFBLFFBQ0osS0FBSztBQUNELGdCQUFNLEtBQUssVUFBVSxZQUFZO0FBQ2pDLGVBQUssT0FBTyxjQUFjLE9BQU8saUNBQWlDO0FBQ2xFLGVBQUssYUFBYTtBQUNsQjtBQUFBLFFBQ0osS0FBSztBQUNELGVBQUssT0FBTyxjQUFjLE9BQU8sMkJBQTJCLE1BQU07QUFBQSxFQUFZLE1BQU0sT0FBTztBQUMzRixlQUFLLGFBQWE7QUFDbEI7QUFBQSxNQUNSO0FBQUEsSUFDSjtBQUVBLFNBQUssT0FBTyxVQUFVLENBQUMsVUFBc0I7QUFDekMsWUFBTSxlQUFlO0FBQ3JCLFlBQU0sZUFBZSxNQUFNLFdBQVc7QUFDdEMsV0FBSyxPQUFPLGNBQWMsT0FBTywyQkFBMkIsY0FBYztBQUMxRSxjQUFRLE1BQU0scUJBQXFCLEtBQUs7QUFDeEMsV0FBSyxhQUFhO0FBQUEsSUFDdEI7QUFFQSxVQUFNLGVBQWUsTUFBTSxLQUFLLGFBQWE7QUFDN0MsU0FBSyxPQUFPLFlBQVk7QUFBQSxNQUNwQixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxPQUFPLEtBQUssT0FBTyxTQUFTO0FBQUEsTUFDNUIsU0FBUyxLQUFLLE9BQU8sU0FBUztBQUFBO0FBQUEsSUFDbEMsQ0FBQztBQUFBLEVBQ0w7QUFBQTtBQUFBLEVBR1csZUFBZTtBQUNsQixRQUFJLEtBQUssUUFBUTtBQUNiLFdBQUssT0FBTyxVQUFVO0FBQ3RCLFdBQUssU0FBUztBQUFBLElBQ2xCO0FBQ0EsU0FBSyxhQUFhO0FBQ2xCLFNBQUssT0FBTyxjQUFjLGVBQWU7QUFBQSxFQUM3QztBQUFBLEVBRUEsTUFBYyxlQUE2RDtBQUN2RSxVQUFNLFFBQVEsS0FBSyxPQUFPLElBQUksTUFBTSxpQkFBaUI7QUFDckQsVUFBTSxrQkFBa0IsS0FBSyxPQUFPLFNBQVM7QUFFN0MsVUFBTSxrQkFBa0I7QUFBQSxNQUNwQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUVBLFVBQU0saUJBQWlCLE1BQU0sT0FBTyxVQUFRO0FBQ3hDLFlBQU0sSUFBSSxLQUFLO0FBQ2YsVUFBSSxnQkFBZ0IsS0FBSyxVQUFRLEVBQUUsV0FBVyxJQUFJLEtBQUssRUFBRSxTQUFTLE1BQU0sSUFBSSxDQUFDO0FBQUcsZUFBTztBQUN2RixVQUFJLGdCQUFnQixLQUFLLFlBQVUsRUFBRSxXQUFXLE1BQU0sQ0FBQztBQUFHLGVBQU87QUFDakUsYUFBTztBQUFBLElBQ1gsQ0FBQztBQUVELFVBQU0sZUFBZSxNQUFNLFFBQVE7QUFBQSxNQUMvQixlQUFlLElBQUksT0FBTyxVQUFVO0FBQUEsUUFDaEMsTUFBTSxLQUFLO0FBQUEsUUFDWCxTQUFTLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTSxXQUFXLElBQUk7QUFBQSxNQUN4RCxFQUFFO0FBQUEsSUFDTjtBQUVBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxNQUFjLFVBQVUsY0FBNkI7QUFDakQsVUFBTSxZQUFZLEdBQUcsS0FBSyxPQUFPLElBQUksTUFBTTtBQUMzQyxVQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sUUFBUSxNQUFNLFdBQVcsS0FBSyxVQUFVLGNBQWMsTUFBTSxDQUFDLENBQUM7QUFBQSxFQUM5RjtBQUNKOzs7QUNoSUEsSUFBQUMsbUJBQXdDO0FBR2pDLElBQU0scUJBQXFCO0FBRTNCLElBQU0sZUFBTixjQUEyQiwwQkFBUztBQUFBLEVBS3ZDLFlBQVksTUFBcUIsUUFBa0I7QUFDL0MsVUFBTSxJQUFJO0FBTGQsd0JBQVE7QUFDUix3QkFBUTtBQUNSLHdCQUFRO0FBSUosU0FBSyxTQUFTO0FBQUEsRUFDbEI7QUFBQSxFQUVBLGNBQWM7QUFDVixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsaUJBQWlCO0FBQ2IsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVBLE1BQU0sU0FBUztBQUNYLFVBQU0sWUFBWSxLQUFLO0FBQ3ZCLGNBQVUsTUFBTTtBQUNoQixjQUFVLFNBQVMsTUFBTSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFHeEQsVUFBTSxnQkFBZ0IsVUFBVSxVQUFVO0FBQzFDLGtCQUFjLFNBQVMsTUFBTSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBSS9DLFVBQU0sa0JBQWtCLFVBQVUsVUFBVTtBQUM1QyxvQkFBZ0IsU0FBUyxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbkQsVUFBTSxjQUFjLGdCQUFnQixTQUFTLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2pGLFVBQU0sYUFBYSxnQkFBZ0IsU0FBUyxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsTUFBTSxFQUFFLFVBQVUsT0FBTyxFQUFFLENBQUM7QUFDM0csVUFBTSxzQkFBc0IsZ0JBQWdCLFNBQVMsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFN0YsZ0JBQVksYUFBYSxNQUFNLEtBQUssT0FBTyxRQUFRLGNBQWMsQ0FBQztBQUNsRSxlQUFXLGFBQWEsTUFBTSxLQUFLLE9BQU8sUUFBUSxhQUFhLENBQUM7QUFDaEUsd0JBQW9CLGFBQWEsTUFBTSxLQUFLLE9BQU8sVUFBVSxRQUFRLENBQUM7QUFHdEUsVUFBTSxrQkFBa0IsVUFBVSxVQUFVO0FBQzVDLG9CQUFnQixTQUFTLE1BQU0sRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNuRCxTQUFLLGNBQWMsZ0JBQWdCLFNBQVMsVUFBVTtBQUN0RCxTQUFLLFlBQVksTUFBTSxRQUFRO0FBRy9CLFVBQU0sY0FBYyxVQUFVLFVBQVU7QUFDeEMsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFDM0MsU0FBSyxlQUFlLFlBQVksU0FBUyxPQUFPLEVBQUUsS0FBSyxvQkFBb0IsQ0FBQztBQUFBLEVBQ2hGO0FBQUEsRUFFQSxPQUFPLFNBQWlCO0FBQ3BCLFVBQU0sVUFBVSxLQUFLLGFBQWEsU0FBUyxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDbkUsU0FBSyxhQUFhLFlBQVksS0FBSyxhQUFhO0FBQUEsRUFDcEQ7QUFBQSxFQUVBLGVBQWUsV0FBbUIsT0FBZTtBQUM3QyxTQUFLLFlBQVksTUFBTTtBQUN2QixTQUFLLFlBQVksUUFBUTtBQUFBLEVBQzdCO0FBQUEsRUFFQSxrQkFBa0I7QUFDZCxTQUFLLFlBQVksY0FBYywrQkFBK0IsR0FBRyxhQUFhLFlBQVksTUFBTTtBQUNoRyxTQUFLLFlBQVksY0FBYyw4QkFBOEIsR0FBRyxnQkFBZ0IsVUFBVTtBQUFBLEVBQzlGO0FBQUEsRUFFQSxpQkFBaUI7QUFDYixTQUFLLFlBQVksY0FBYywrQkFBK0IsR0FBRyxnQkFBZ0IsVUFBVTtBQUMzRixTQUFLLFlBQVksY0FBYyw4QkFBOEIsR0FBRyxhQUFhLFlBQVksTUFBTTtBQUMvRixTQUFLLFlBQVksUUFBUTtBQUFBLEVBQzdCO0FBQ0o7OztBTGxFQSxJQUFxQixXQUFyQixjQUFzQyx3QkFBTztBQUFBLEVBQTdDO0FBQUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSxFQUVBLE1BQU0sU0FBUztBQUNYLFVBQU0sS0FBSyxhQUFhO0FBQ3hCLFVBQU0sYUFBYSxHQUFHLEtBQUssU0FBUztBQUNwQyxVQUFNLGFBQWEsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLElBQUksTUFBTSxRQUFRLEtBQUssVUFBVSxDQUFDLEdBQUcsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3hHLFNBQUssWUFBWSxJQUFJLGdCQUFnQixVQUFVO0FBRS9DLFNBQUssWUFBWSxJQUFJLFVBQVUsSUFBSTtBQUNuQyxVQUFNLGFBQWEsR0FBRyxLQUFLLFNBQVM7QUFDcEMsU0FBSyxVQUFVLElBQUksUUFBUSxNQUFNLFVBQVU7QUFFM0MsU0FBSyxjQUFjLElBQUksZUFBZSxLQUFLLEtBQUssSUFBSSxDQUFDO0FBRXJELFNBQUs7QUFBQSxNQUNEO0FBQUEsTUFDQSxDQUFDLFNBQVUsS0FBSyxlQUFlLElBQUksYUFBYSxNQUFNLElBQUk7QUFBQSxJQUM5RDtBQUVBLFNBQUssY0FBYyxpQkFBaUIsOEJBQThCLE1BQU07QUFDcEUsV0FBSyxhQUFhO0FBQUEsSUFDdEIsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ1osSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNO0FBQ1osYUFBSyxRQUFRLGNBQWM7QUFBQSxNQUMvQjtBQUFBLElBQ0osQ0FBQztBQUVELFVBQU0sS0FBSyx1QkFBdUI7QUFDbEMsVUFBTSxLQUFLLFVBQVUsTUFBTTtBQUFBLEVBQy9CO0FBQUEsRUFFQSxXQUFXO0FBQ1AsU0FBSyxVQUFVLEtBQUs7QUFDcEIsUUFBSSxLQUFLLGNBQWM7QUFDbkIsV0FBSyxhQUFhLEtBQUssT0FBTztBQUFBLElBQ2xDO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQUEsRUFDN0U7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNqQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNyQztBQUFBLEVBRUEsTUFBTSx5QkFBeUI7QUFBQSxFQUUvQjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFNBQUssSUFBSSxVQUFVLG1CQUFtQixrQkFBa0I7QUFFeEQsVUFBTSxPQUFPLEtBQUssSUFBSSxVQUFVLGFBQWEsS0FBSztBQUNsRCxRQUFJLE1BQU07QUFDTixZQUFNLEtBQUssYUFBYTtBQUFBLFFBQ3BCLE1BQU07QUFBQSxRQUNOLFFBQVE7QUFBQSxNQUNaLENBQUM7QUFFRCxXQUFLLElBQUksVUFBVSxXQUFXLElBQUk7QUFBQSxJQUN0QztBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiJdCn0K
